[[domains]]
= DOMAINS are the primary ENTITY in the UDG

== ENTITIES are the basic type for all knowledge in the UDG

The UDG KG is composed of Spatial Web ENTITIES.  An ENTITY is that which is perceived, known, or inferred to exist, has existed, or is anticipated to exist.  ENTITIES are of several types as shown in the <<hsml_ontology>> which are the primary concepts used across the Spatial Web and in the Hyperspace Modeling Language (HSML).  HSML implements the Spatial Web ontology as a set of schemas that enable increased coherence across diverse datasets without sacrificing flexibility.  

[[spatial_web_ontology]]
.Spatial Web ontology
image::spatial_web_ontology.png[ontology showing Spatial Web entities and their relations]


== SWIDS and Aliases

=== UDG and SWIDs

All ENTITIES in the UDG KG have a __Spatial Web Identifier__  known as a __SWID__. The SWID serves a number of purposes:

* A SWID is a decentralized identifier (DID) for digital identity devoid of any type of centralization (see <<w3c_did>>)
* The SWID identifies the ENTITY uniquely within the Spatial Web. In this regard, the SWID acts as an (indirect) IRI.
* SWIDs are also used to establish links between resources. 
* SWIDs are also used to resolve __nodelink__ connections between different nodes in the SW Node Graph, making it possible to bind together nodes in networks. In this case, the __nodelink document__ identifies both authentication and address information for different nodes within the spatial web.

=== Aliases

In the Spatial Web, one or more *__aliases__* can be assigned to a SWID that is intended to locate a resource, but the actual "physical" address for the resource is contained within the SWID Document. In effect, the alias is analogous to a HTTP domain name mapping to an IPV6 address, but in this case the "domain name" alias maps to a SWID, which then maps to the corresponding IPV6.

[[fig-swid-alias]]
.SWID Alias
image::SWID-alias.png[SWID Alias]

// [source,mermaid]
// ----
// flowchart LR
// Alias --> SWID1 --> doc["Verifiable<br>Credential"]
// doc --> SWNode[Spatial Web Node]
// doc --> Domain[Reference Domain]
// ----


EDITOR:  The specific form of aliases is still to be determined. To be consistent with other SWF specificaitons, the figure may need to be revised, inserting "SWID Document"  between SWID1 and "Verifiable Credential." 


== Definition of a DOMAIN

A DOMAIN is the fundamental class within the UDG for describing the various things, agents, and places that make up the Spatial Web. Every structure, building, planet, character (agent), animal, mystical alien pyramid or similar construct, is ultimately a DOMAIN, and is addressable within the context of the Spatial Web.

A DOMAIN is an ENTITY that may identify the context for an ACTIVITY for or by an AGENT at a specific place acting upon various things within that DOMAIN. Everything that happens within the UDG happens within a DOMAIN.

A DOMAIN is required to have these attributes:

* a SWID, a form of decentralized identifier that can be used to identify the domain uniquely within the Spatial Web.
* A DOMAIN Type, which indicates the particular role that the domain plays. This identifies how the domain is classified within the Spatial Web. Note that a DOMAIN can be defined by multiple different ontologies, but it _must_ have the domain type.

A DOMAIN may have other other attributes, but these are not required:

* A __location__, which identifies the entity's position in HYPERSPACE, relative to either the containing DOMAIN, or to an externally defined DOMAIN. If a domain exists solely as a vehicle for containment, then location is not specifically required, though it often contains additional state information that is not strictly speaking positional.
* Zero or more ACTIVITIES, which provids operational instructions for the entity in question. 
* Zero or more __style__ resources, which provides a mechanism for rendering the DOMAIN with different content types. _EDITOR:  this has not been formally proposed yet, and may be removed.
* Zero or one __link__ references to an external DOMAIN. Some ENTITIES provide a link that can be activated through certain interfaces or affordances. This is a simple link, meaning it changes the context (DOMAIN) of the agent initiating the
link without specific constraints, which is analogous to an HTTP standard hyperlink. More information about links will be covered in the subsection <<links,Links>>.


== DOMAIN types

A DOMAIN type is a specialization of a DOMAIN that incorporates additional capabilities.  <<IEEE Std 2874>> defines several DOMAIN types:


[[domain-types-based-on-their-defining-characteristics]]
.Domain types based on their defining characteristics
[%autowidth]
|===
|Type of Domain |Description

|Geographic
|Implicitly or explicitly associated with a location
|Concept
|Intangible concepts and abstract ideas shared by a community of users
|Organization
|Pertaining to membership within an entity
|Agent
|Individual domains with active states and agency
|Person
|Special subtype of agent maintaining a self-sovereign identity
|Thing
|Bounded items without agency
|===


EDITOR: the additional concepts related to DOAMIN types is under review.

Additional concepts are being considered relevant to DOMAIN types. These are differentiated as follows:

* A __place__ is defined roughly as a specific addressable location within a domain. Places define where an entity can be, and where they can't. Cf <<places,Places>> for more information.

* A __link__ is a mechanism for navigating between both places (internal links) and domains (external links). It is the analog of a hypertext link in the HTTP world.Cf. <<links,Links>> for more information.

* A __sensor__ is an abstraction of a camera, recording device, eyeball, etc. Its purpose is to provide a reference point of view for an entity within a domain (or of the domain itself).  Cf. <<sensors,Sensors>> for more information.


* An __assemblage__ is an aggregate structure of things, places, and agents. It is intended to model corporations, institutions, governments, and so forth, but it can also model physical or other composite structures.  Cf. link:#assemblages[Assemblages] for more information.


== DOMAIN modeling checklist

A DOMAIN provides the answers to a number of key questions about the system in question.

* __Where?__. Where (what place) does the action within the system take place?
* __How Is Space Defined?__ What are the relevant places of relevance within the system (it's hyperspace).
* __How Is Spae Connected?__. How are things within the domain connected, and how are domains connected to other domains?
* __What Happened?__. Is it possible to retrieve a history of what happened within the domain over time?
* __What Kind?__. What classifications apply to the domain?
* __Who?__. Which agents are participating within the domain?
* __When?__. When does the activity take place within the context of the domain. This becomes especially critical for asynchronous events.
* __What Happened?__. Is it possible to retrieve a history of what happened within the domain over time?
* __How?__. What are the activities that can be accomplished within the domain, and how are these activated?
* __Why?__. What are the goals or purposes of the domain, and what happens when those goals are achieved?


DOMAINS may be references using hyperspace including time. DOMAINS usually have a specific start time (or other condition) and end time (or other condition).

In general, a domain has a schematic representation that can be extended from a core domain type. This identifies the relevant state variables and properties for the domains beyond the properties of the Domain base class. Domains are entities in that they have SWIDs, but they are in effect system (or holonic) entities.

== Extending Entities

While the Spatial Web makes use of the Domain Types defined in <<IEEE Std 2874>>, those types may need to be extended to model the complexity of all worlds.  A framework is defined that can identify nodes contextually using topics and state dependencies. For instance, suppose that you wanted to add a property to a given country called population. In this case, a property node can be added using SHACL.

----
[] a hsml:Domain ;
    hsml:hasShape [
        a sh:NodeShape ;
        sh:targetClass hsml:Place ;
        sh:property [
            a sh:PropertyShape ;
            sh:path ex:population ;
            sh:nodeKind sh:Literal ;
            sh:datatype xsd:nonNegativeInteger;
            sh:minOccurs 0 ;
            sh:maxOccurs 1 ;
        ],[
            a sh:PropertyShape ;
            sh:path hsml:hasTopic ;
            sh:nodeKind sh:IRI ;
            sh:class hsml:Topic ;
            sh:value <#concept/Country> ;
        ]
     ] .
----

In this case, the domain holds the shape definitions via the `hsml:hasShape` property, and when the domain is instantiated, this provides information to the system about how the given property or properties are implemented.

For instance, in this particular case, the place (a country) is defined with a property `ex:population` as well as a second property `hsml:hasTopic`. The first is considered valid if it has a nonNegative integer (and is an optional parameter), the second is considered valid if the hsml:hasTopic property has the value <concept/Country>. If either of these are not true for the place, then the structure generates an error for the shape.

Within the graph, then, this would be applied to the Canada place node as follows:

----
[] a hsml:Place ;
    hsml:swid did:swid:0CANADA ;
    hsml:swurl <#country/Canada> ;
    hsml:hasTopic <#concept/Country> ;
    ex:population 32159219 ;
    .
----

This makes it possible to add any number of properties to entities within the domain in question, as well as to set constraints that more accurately specify things such as topicality or state configurations.

Note that common shapes can be bound specifically to reference domains and included or imported, as specified in the section
link:#importing-taxonomies-and-schemas[Importing Taxonomies and Schemas].


== The UDG Taxonomy

The __UDG Taxonomy__ is a taxonomy designed to augment discovery within the Spatial Web by providing common concepts and definitions for agents and, by extensions, domains.

=== The hsml:hasTopic property

The UDG Taxonomy can be thought of as the thesaurus for the Spatial Web. Each term in that thesaurus provides an adjective or noun that identifies some characteristic of a given agent.

For instance, an agent that is intended to be a proxy for a car in a smart city scenario may be identified by a number of such characteristics: the vehicle's _make_, _model_, and _trim_, its _carriage designation_ (a sedan, sports car, SUV, light truck), its _primary and secondary external and internal colors_, its _engine type_ (internal combustion engine, diesel, electric, hybrid, hydrogen-powered) and so forth. A building may be classified by _purpose_, _construction method_, _zone classification_, etc. A robot may be given by its _purpose_, _ambulatory status_, _activation level_, etc.

Each of these terms are used primarily as mechanisms for classification, and are considered as __categories__, with each particular enumeration in turn considered a __topic__. The `hsml:hasTopic`, `Place:hasTopic` and `hsml:hasTopic` properties in HSML takes zero or more topics as arguments.

[[fig-udg-taxonomy]]
.UDG Taxonomy
image::UDG_Taxonomy.png[UDG Taxonomy]


// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph LR
//     car1[<b>Agent</b><br>Car 1]:::agent
//     car2[<b>Agent</b><br>Car 2]:::agent
//     automobile[<b>Topic</b><br>Automobile]:::topic
//     sedan[<b>Topic</b><br>SUV]:::topic
//     toyota[<b>Topic</b><br>Toyota]:::topic
//     camry[<b>Topic</b><br>Camry]:::topic
//     corolla[<b>Topic</b><br>Corolla]:::topic
//     XE[<b>Topic</b><br>XE]:::topic
//     AE[<b>Topic</b><br>AE]:::topic
//     car1 -->|hsml:hasTopic| automobile & sedan & toyota & camry
//     car2 -->|hsml:hasTopic| automobile & sedan & toyota & corolla & AE
//     carriage[<b>Category</b><br>Carriage]:::category
//     make[<b>Category</b><br>Make]:::category
//     model[<b>Category</b><br>Model]:::category
//     trim[<b>Category</b><br>Trim]:::category
//     domainType[<b>Category</b><br>Domain Type]:::category
//     carriage --->|hsml:hasTopic| sedan
//     make --->|hsml:hasTopic| toyota
//     model --->|hsml:hasTopic| camry
//     model --->|hsml:hasTopic| corolla
//     trim --->|hsml:hasTopic| XE
//     trim --->|hsml:hasTopic| AE
//     domainType --->|hsml:hasTopic| automobile
// %%%    camry -->|hsml:hasConstraint| toyota
// %%%    corolla -->|hsml:hasConstraint| toyota
// %%%    XE -->|hsml:hasConstraint| camry
// %%%    AE -->|hsml:hasConstraint| corolla
//
// style car1 stroke-width:4
// classDef node stroke:black
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----

The power of the UDG taxonomy is in its ability to cluster agents by topic, mediated by category. For instance, car 1 and car 2 are both of the same make (Toyota) but of different models (Camry vs. Corolla) and trims. They are also of the same "domain Type" of automobile. Note that domain type here is not privileged, it is simply one more category that agents can be in, though a fairly broad category.

=== The `hsml:hasConstraint` Property

Some times there are interdependencies between topics. For instance, the Corolla and the Camry are two different models produced by Toyota, and another car company will not produce those same models. Similarly trim provides variants for a given car model.

These relationships are called _constraints_, which is a relationship indicating that one topic is dependent upon another. This changes the diagram somewhat:

[[fig-udg-taxonomy-constraints-example]]
.An example of the UDG Taxonomy with constraints
image::UDG_taxonomy_example_with_constraints.png[an example of the UDG Taxonomy with constraints]

// https://www.mermaidchart.com/app/projects/ecd8eb1d-8b86-4074-9e57-f89503604e51/diagrams/463b3340-401b-4c6f-a24b-48310639b1db/version/v0.1/edit
// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph LR
//     car1[<b>Agent</b><br>Car 1]:::agent
//     car2[<b>Agent</b><br>Car 2]:::agent
//     automobile[<b>Topic</b><br>Automobile]:::topic
//     sedan[<b>Topic</b><br>SUV]:::topic
//     toyota[<b>Topic</b><br>Toyota]:::topic
//     camry[<b>Topic</b><br>Camry]:::topic
//     corolla[<b>Topic</b><br>Corolla]:::topic
//     XE[<b>Topic</b><br>XE]:::topic
//     AE[<b>Topic</b><br>AE]:::topic
//     car1 -->|hsml:hasTopic| automobile & sedan & toyota & camry
//     car2 -->|hsml:hasTopic| automobile & sedan & toyota & corolla & AE
//     carriage[<b>Category</b><br>Carriage]:::category
//     make[<b>Category</b><br>Make]:::category
//     model[<b>Category</b><br>Model]:::category
//     trim[<b>Category</b><br>Trim]:::category
//     domainType[<b>Category</b><br>Domain Type]:::category
//     carriage --->|hsml:hasTopic| sedan
//     make --->|hsml:hasTopic| toyota
//     model --->|hsml:hasTopic| camry
//     model --->|hsml:hasTopic| corolla
//     trim --->|hsml:hasTopic| XE
//     trim --->|hsml:hasTopic| AE
//     domainType --->|hsml:hasTopic| automobile
//     camry --->|hsml:hasConstraint| toyota
//     corolla --->|hsml:hasConstraint| toyota
//     XE -->|hsml:hasConstraint| camry
//     AE -->|hsml:hasConstraint| corolla
//
// style car1 stroke-width:4
// classDef node stroke:black
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----


=== Geographic DOMAINS with `hsml:hasTopic` and `hsml:hasConstraint`

Geographic DOMAINS can be defined in a similar manner. For instance, a place may be a country, city, planet, river, lake, sea, township, etc., Each of these are `geoFeature` topics, though these may be subclassed.

For instance, Vancouver, British Columbia, Canada, and North America are all places, they are connected as follows:

[[fig-udg-taxonomy-geofeature]]
.UDG Taxonomy example with a GeoFeature
image::UDG_Taxonomy_GeoFeature.png[UDG Taxonomy example with a GeoFeature]

// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph TD
//     vancouver[<b>Place</b><br>Vancouver]:::place
//     bc[<b>Place</b><br>British Columbia]:::place
//     can[<b>Place</b><br>Canada]:::place
//     nam[<b>Place</b><br>North America]:::place
//     earth[<b>Place</b><br>Earth]:::place
//     un[<b>Agent</b><br>United Nations]:::agent
//     city[<b>Topic</b><br>City]:::topic
//     province[<b>Topic</b><br>Province]:::topic
//     country[<b>Topic</b><br>Country]:::topic
//     continent[<b>Topic</b><br>Continent]:::topic
//     planet[<b>Topic</b><br>Planet]:::topic
//     geoFeature[<b>Category</b><br>Geo-Feature]:::category
//     org[<b>Category</b><br>Organization]:::category
//     ngo[<b>Topic</b><br>Non-Governmental Organization]:::topic
//     geoFeature -->|hsml:hasTopic| city & province & country & continent & planet
//     vancouver --->|hsml:hasConstraint| bc
//     bc --->|hsml:hasConstraint| can
//     can -->|hsml:hasConstraint| nam
//     nam -->|hsml:hasConstraint| earth
//     can -->|hsml:hasConstraint| un
//     vancouver --->|hsml:hasTopic| city
//     bc --->|hsml:hasTopic| province
//     can --->|hsml:hasTopic| country
//     nam --->|hsml:hasTopic| continent
//     earth --->|hsml:hasTopic| planet
//     un ---> |hsml:hasTopic| ngo
//     org ---> |hsml:hasTopic| ngo
//
// classDef node stroke:black
// classDef place fill:lightGreen
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----

In this case, while these are all geoFeatures, Vancouver is a city while Canada is a country. Significantly, the implicit structuring (Vancouver is a part of Canada) becomes simply a constraint relationship here, albeit one that can be exploited for reasoning purposes. Furthermore, Canada might also be in another constraint relationships with an organization of countries (such as NAFTA or the United Nations), so the hierarchy here is a hierarchy of topics, and is actually more holonic than strictly hierarchical.

=== Topics vs. States

At first glance, topics and state properties would appear to be similar - one
could express topics as states, though they serve somewhat different purposes. A
state typically associates a facet value with a normalized value indicating the
strength of that value, while a topic typically is a binary relationship used
for classification exclusively (you could say that a state property is a topic
with a value of either 0 or 1, not something in between).

Moreover, topics tend to be relatively stable once assigned to an agent or
place. This makes them useful for classification, and discovery. For instance,
while it is possible to identify the state of a traffic light as being red or
green, this value is likely to change regularly between queries. However, it's
designation as a traffic light is very much unlikely to change. meaning that if
you look for traffic lights on a given node, you will likely get all such
agents.

Discovery on a given spatial web node then becomes a matter of querying the node
for desired topics. Note that the topics can include synonyms (analogous to
`skos:altLabel`) that can be compared to the base topic labels for mapping to
the respective node. Moreover, multiple language versions of the same topic can
be provided in order to match in different languages.

Note that topics can be used for state variables. In that particular case,
however, they won't necessarily participate in search unless they are also
incorporated as hsml:hasTopic objects.

=== Taxonomies and Schemas with Domains

A taxonomy is a data structure that defines the topics that are relevant to that
domain. The predicate `hsml:hasCategory` identifies the categories that are
defined within the domain (and is a property of the hsml:Domain class). Each
category in turn identifies one or more topics that are associated with that
category. Because domains are named graphs, the categories defined are local to
that domain.

[[fig-udg-gameworld]]
.Game World
image::GameWorld.png[Game world]

// [source,mermaid]
// ----
// graph LR
//    gameWorld[<b>Domain</b><br>Game World]
//    swords[<b>Category</b><br>Swords]
//    axes[<b>Category</b><br>Axes]
//    rapier[<b>Topic</b><br>Rapier]
//    gladius[<b>Topic</b><br>Gladius]
//    katana[<b>Topic</b><br>Katana]
//    halberd[<b>Topic</b><br>Halberd]
//    battleaxe[<b>Topic</b><br>Battle Axe]
//
//    gameWorld -->|has Category| swords & axes
//    swords -->|has Topic| rapier & gladius & katana
//    axes -->|has Topic| halberd & battleaxe
//----

=== Importing Taxonomies and Schemas

The predicate `hsml:includeDomain` is an instruction to add the graph of the
indicated domain as part of the graph search, and is applied to the hsml:Domain
object. This makes it possible to import external taxonomies and schemas into an
existing domain. This has a lot of utility, in that it means that a domain can
be defined that contains common taxonomy and schema definitions which can then
be used within another domain.

Typically, a spatial web node will contain a primary domain that contains many
of the core concepts, structures, and places and common agents that may be used
within the majority of domains on that node. This can be imported into any given
domain, providing a common framework for terms. In general, this is like a link
in that the SWURL for the resource is passed. This is then interpreted by HSML
(through the graph.d engine) to add this as resource into the active graph for
the domain.

This can also be done across node boundaries. A __resource repository__ is a
domain server that contains various entity resources that may be used across the
entirety of the spatial web. By working from these common repositories, entities
such as common places, frequently defined agents, taxonomy terms, and so forth
can be referenced within a domain, while staying up to date.

Note that because of latency considerations, there are times where it may be
more advantageous to autoload an external domain's contents permanently onto a
given spatial web node. The `hsml:importDomain` is similar to the
`hsml:includeDomain` but copies the imported domain content to the server
directly, rather than referencing them from an external server. This creates an
internal domain, and requires that you specify both the external SWURL and the
internal name:

----
[] a hsml:Domain ;
    hsml:swurl <domain/ExternalTaxonomy>
    hsml:importDomain <https://myExternalResources.com#domain/externalTaxonomy> .
    .
----

When this is interpreted by the hsml parser, it will retrieve the subgraph from
the external domain and load it into the graph as a named graph with associated
local-name SWURL. This may frequently be done from packages that are loaded in
initially, and that may be periodicallly refreshed.

The primary difference between `hsml:includeDomain` and `hsml:importDomain` is
that `hsml:includeDomain` creates a domain extension from the external system
that is always up to date but that may have higher latency (and is not actually
stored on the same node as the including domain), while the `hsml:importDomain`
creates a local copy of the external graph in the calling graph. This graph may
be out of date but that has much lower latency.

An example of an included domain would be a hotel that had a number of guest
rooms, each of which were in their own domain (which may or may not be on the
same spatial web node). An example of an imported domain would be one that
incorporated a taxonomy that is commonly used by other domains but that also
does not change frequently and may be heavily referenced.

Another way of thinking about imports vs. includes is that an import is
essentially a cache of one domain within another, while, an include is a
temporary reference.

Note also that in both cases, the node server MUST have the relevant credentials
to load in the external domain. Otherwise this statement will fail and an error
message will be sent to the error channel.
