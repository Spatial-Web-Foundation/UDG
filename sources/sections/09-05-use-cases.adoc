= Use Cases

The following use cases identify operations that are considered part of the UDG. Because these tend to be interrelated, they are provided primarily in terms of creation and navigational progress.

== Setting Up a Spatial Web Node


. Go to Spatial Web Foundation site and download the spatial web foundation application.
. At this time, the authority for the site submits a form that will allow you to specify the domain information, authorization, and categorization for the spatial web node itself.
. At this time, the authority may choose zero or more affiliated networks that the spatial web node may participate in.
. The default network is the Spatial Web Registry Authority, but this doesn't have to be the one selected. Networks are defined thematically (by topic and language) and as such can be searched and ranked (rated).
. Each network is managed by an affiliate manager (a node registry) that maintains a cache of links in its primary domain. These node registries
. Once an ensemble of networks are selected, a request link is sent to each affiliate manager in turn that adds the link to the new node (and it's primary domain) to that of the network in question. If the link is approved then the newly created node is added to the network (see link:#registering-a-node-on-an-affiliation-registry[Registering a Node on Affiliation Registry]).
. Once registered, other domains and other entities can be added to the spatial web node (see link:#creating-an-entity[Creating an Entity]).


== Generating and Resolving SWIDs

. Because of the centrality of SWIDS in the Spatial Web architecture, a Spatial Web Node incorporates a SWID generator/resolver as part of the architecture.
. When an entity is created by the system, a SWID and corresponding documents are created, with the documents (likely public and private keys, or PPKs) stored as graph entities in a cryptographically secured named graph as part of the domain graph.
. This method exists primarily for convenience and performance as in general the ability to retrieve, parse, and reference external blockchains or similar mechanisms will be a major performance hit unless that ability is accessible from (and contained in) the graph.
. This becomes especially important if there is specific surety information within the SWID that is particular to the did.swid method, as will likely be the case.
. The Credential API handles SWID generation and resolution and acts as a wrapper for abstracting multiple different approaches for SWID management.

== Registering a Node on an Affiliation Registry

. Registering an entity on a spatial web node makes that node available for search according to a specific affiliation credential on that entity. What you are actually registering is a link to the entity in question.
. That link may contain additional metadata (such as topical or annotative information) that makes it easier to search for similar entities.
. An affiliate spatial web registry is a spatial web node with a single primary domain that mainly contains links to other entities on other affiliated nodes.
. To register on such an affiliated registry, a domain authority submits a request containing the link and associated metadata to the registry node, and if the request is accepted, a contract is formed by the registry (containing a new SWID) that contains the relevant links and metadata, and a credential containing this contract is then sent back to the requesting node, where it is stored in the relevant domain (typically the home domain of the node).
. Note, the registry does not contain the indicated entity, only a reference to that entity in the form of a link on a contract.

== Searching an Affiliation Registry (User Client)

. When a user client is downloaded, the user is directed to a web page that lets the user select one or more affiliation networks (including the Spatial Web Registry Authority).
. Alternatively, the user can download affiliation packages that contain links to common affiliation servers in a bundle.
. Affiliation servers periodically read each of spatial web node within their affiliation and extract links and metadata of those  entities that have been given an affiliation credential (typically domains, but they could be other resources).
. The client sends a request that can be decomposed as taxonomic metadata (or by indexing descripions and labels via vector search or AI), which can then be used to retrieve the links that best match the search.
. It should be noted that the affiliation registries will generally not be completely current (they will typically iterate through their affiliated nodes on a daily basis, but probably not much faster than that), and this will only pick up the domains and other entities that have received an affiliation credential.
. It is also possible (albeit probably not advisable) to retrieve a list of affiliates directly and query each node independently. It would require the user client, however, having the relevant credentials for each domain on each node

== Refreshing a Registry

. Periodically, a registry will iterate through its contracts and request updated metadata from an affiliated node for entities that have the relevant affiliated credentials.
. Not all (not even most) entities on a given node will have these credentials, only those that need to be identified by the affiliation registry.
. Similarly, a node may be self-affiliated, with the home domain containing contracted links for entities that are considered important enough to be visible for search on that domain. This can be considered the directory for that node. A registry is a directory for domains (formally entities) that are external to that node.

== Logging Into a Domain

__Requirements:__ DSA-5

. An external agent (such as a user agent) will have a link to a domain, presented as a SWID or SWURL, and will send this (with any appropriate metadata) to the resolved spatial web node.
. The SWNode (the node manager) receives a request to initiate a connection, determines whether the relevant domain exists, and determines whether the external agent already has a proxy agent on the system representing that external agent.
. If the agent exists and the credential to access that agent is cached for (perhaps within, TBD) the relevant domain, then a channel is established between the external agent and the proxy agent, with a message then sent back to the external agent providing confirmation.
. If no credential exists (either this is a new user agent or the credential has expired), the SWNode sends a message back to the external agent requesting credentials. In the case of expiry, this is just a revalidation, new credentials are set up and the connection is made.
. If no agent exists for that domain, then a new agent is registered, typically at the home place for that domain, once credentials have been created and confirmed. This is the proxy agent for that user agent on that domain.

== Creating an Entity []

. Request a credential to create a particular entity (domain, agent, place, etc.).
. If the credential is valid, this returns a SWID for the parent entity.
. Submit an HSML document that describes the entity, using an HSML posted message that includes the containing SWID (this may be accomplished via some form of an editor)
. The HSML document is checked for validity, and is rejected if it fails a validity check.
. If the document is accepted, the document is created within a named graph.
. For all entities within the named graph, SWIDs are created and attached to each entity.
. The named graph identifier is then attached to the parent entity.
. At the time of creation, an entity MUST be assigned an ___Internal State domain___ or ___IS Domain___ (see link:#changing-internal-state-domain-of-an-entity[Changing Internal State Domain]).
. At the time of creation, an entity MAY be assigned a ___level of detail domain___ or ___LoD Domain___ (see link:#changing-level-of-detail[Changing Level of Detail]).
+
NOTE: _It is possible that this will need to be changed to MUST and needs further discussion_.

== Attach a Credential to an Entity

. If an agent has a relevant mutation credential on a given entity (meaning that they can edit that node), the agent can attach a credential referencing the SWID of that entity through HSTP.
. If the credential is an affiliation credential, then the entity becomes visible through queries against that node if the querant has the corresponding affiliation key.
. A public entity is one that has a Public Affiliation Key, meaning that it is visible to anyone on the spatial web if they reference the spatial web node. This will generally apply to domains.
. All immediate entities within a domain will share the credentials within that domain. If a subdomain exists on an entity, the entity needs to extend the credential to that domain explicitly.

== Invalidate an Entity

. An entity is made invalid by setting the :isInactive flag (typically through a sparql update).
. An inactive entity remains in the system but is no longer visible to queries (all queries check the inactive flag for that entity).
. When an entity is made inactive, the datetime is noted, and after a system settable time, the entity will be purged. Note that if an entity has a subordinate or linked domain, that domain will NOT be made inactive (there may be other references to the subdomain).
. All queries against an entity must specifically check to see if the entity is valid before returning it as part of a search result.

== Querying an Entity

. All entities have a default Query Activity that will retrieve a JSON-LD representation of that entity (this may not be a faithful copy of the internal state of the entity).
. The editor of that entity may incorporate one or more override activities that provides different representations based upon parameters sent within the HSTP request message.
. The querant may request that the query be made subscribable, which means that a new message is passed every time a change is made to the state of the entity in question.

== Querying a Specific State of an Entity

. The querant can request a specific state variable for a given entity. This will retrieve a JSON structure containing the variable and it's associated value.
. As with querying an entity, querying the state of an entity can be done asynchronously using a pub/sub protocol. This will return information about the state periodically as it changes.
. A query can also be made to retrieve the entity state array, either once or upon state changes.
. Any asynchronous query will return an identifier for that query, and the calling agent may cancel the query by passing back that identifier.

== Modifying the Specific State of an Entity

. If a particular state of an entity is  modifiable, then this will cause a mutation event to occur that will instruct the entity to initiate a mutation activity to occur.
. In the simplest (default) case, this just updates the value of the state in the graph.
. If the agent is autonomous, this will cause the agent manager to attempt to align the agent to the requested condition.
. If the agent is also bound to a physical twin, the agent manager will make the attempt to change the state of the physical twin before updating. If this fails, an error will be raised, and any changes will be rolled back.

== Subscribing to a State of an Entity

. Subscribing to the state of an entity is the same as querying the state of an entity asynchronously.
. When a state changes in the subscribed entity, the subscribing entity will receive a notification (via domain.d) that can be caught with a subscribed state update event activity (the default is to do nothing).
. If the publishing entity is located on a different node, the message will be routed through hstp.d first, and then to the relevant entity.
. The first message returned from the publisher will be the current state, even if that state has not changed.
. The exact contents of various entity state descriptors are TBD, but will likely be a stream of contained entity messages (filtered by specific state if this is requested).
. Typically, such messages will be managed over channels, possibly as a part of a message queue.

== Extending an Entity Graph

. The graph for a given entity (primarily domains) may be extended by use of the hsml:include property.
. This provides a (generally) read-only ability to query an exterior graph, either from a different domain on the current machine, a different domain from an external domain, or a non-spatial web graph resource.
. This is frequently used to access domains containing collections of commonly defined entities (such as places, activities, agents, contracts and so forth).
. Such extensions typically require having the relevant credentials to access the external servers, and more than likely will be associated with affiliated nodes.

== Importing an Entity Graph
. An imported graph is one that is copied from an entity outside the existing domaing graph. Unlike extended graphs, imports effectively copy the contents of the given external entity but assign new SWIDs. SWURLs are typically fragments, so take on a new identifier (via it's HTTP domain).
. Importing a domain is the same as creating a domain, including assigning new SWIDs as needed.
. Importing a domain creates a copy of that domain. This will typically be use when a domain acts as the "template" that is then filled out parametrically, such as that used by games or simulations.
. Importing a domain is considered an HTTP operation, while extending (including) a domain is part of UDG.

== Interacting with the Domain: User Agents

. A __user agent__ is an agent that represents the interest and focus of an external agent within the domain. It is typically the _thing_ or _person_ that navigates the domain on behalf of that external agent.
. When an external agent "logs in" to a domain, the domain manager establishes a user agent representing that external agent, adding the user agent's credential to the domain credential store.
. If no user agent exists within that domain for that external agent, the domain manager creates that user agent and adds them to the ___home place___ for that domain. This can be thought of as the landing place for new agents.
. If a user agent already exists for the external agent, they will already be sited within the domain at a specific place. This establishes the context for that user agent within the domain.
. A user agent can interact with other agents within a given place, or with agents within an linked neighborhood (agents on a place that is directly connected to the current place). This is called the __interactive neighborhood__.
. Within the interactive neighborhood, the ___state matrix___ and ___activity matrix___ of all other agents in that neighborhood become visible. The activity matrix indicates all ___activities___ that a given agent can perform, relative to the user agent, while the state matrix identifies the state that is exposed to the user agent based upon the same mechanisms (typically a credential).
. It should be noted that such interactions are reciprocal - the user agent also exposes their state and activity matrices to other agents in the same way.
. The interactive neighborhood exists for two reasons - it more closely reflects the reality in which people have personal spaces that determine how they specifically interact, and it serves to reduce the overall complexity of any given domain. Note that if a communication link exists between two agents, this is considered part of the interactive neighborhood for each of those agents.

== Activating an Agent's Activity

. In the case of a user-agent, the external agent is presented an activity matrix that indicates what specific activities the user-agent can perform. One of these activities as `selecting_an_activity`. This allows the agent to choose one from a set of activities that may be available of another agent, and make it the focus for subsequent actions (this may be set up on the agent as the hsml:targetEntity)
. Once an activity is selected, the user agent may then `activate_an_activity`. This is a signal to the targeted agent that the targeting agent is requesting that an activity be accomplished.
. The targeted agent that evaluates the request and, if it is within its capability and goals, will return a contract to the targeting agent with its conditions. If the conditions are acceptable to the targeting agent (for instance, if a fee is involved and paid, establishing a credential) then the activity will be initiated.
. Note that a contract can be extended to cover all activities that are visible to the targeting agent, and can remain in force until explicily terminated. This can reduce the negotiation process for subsequent calls to invoke other activities of a given agent.
. The targeted agent will then asynchronously perform the activity until the activity is completed, whereupon it notifies the targeting agent that the activity has been completed.
. If the targeted agent is unable to complete the activity, then it performs a forfeit activity (such as reimbursing the targeting agent) according to the terms of the contract.
. The activating agent can also perform an action to terminate the contract, but only once the contract has been either satisfied or forfeited. Most simple contracts are self-terminating.

== Maintaining History

. Maintaining history is handled in one of two ways - reifications and sampling, with four total options:
** __Reification__ involves the creation of assertions concerning the changes in the state of the various entities within a given domain. Reification can provide an exact replay of changes over time, but at the cost of performance and additional space.
** __Sampling__ involves the periodic sampling of the state matrix of one or more of the entities in a given domain, persisting them to an external channel. Sampling is more efficient, but it loses resolution.
**  __Neither.__ An entity simply does not maintain a history because it doesn't need to.
** __Both.__ Persistence tracking via reification allows for the replay of a given domain while external reporting can be done on the entity. This is the most comprehensive, but it is also the most processor intensive.
.  Reification is part of the graph services and is managed via graph.d. Sampling is part of the domain services and ties in more closely with HSTP and its associated daemon.

== Changing Internal State Domain of an Entity

. A given non-domain entity (such as a place or an agent) may have as __Internal State Link__  to a different domain that represents the internal state of that entity.
. Such a domain may be empty of child agents or places.
. The current implementation of such an ISL domain is a named graph, but this may change based upon system representation of data structures.
. The ISL graph is used primarily to represent the internal state of that entity, though it can also (especially in the case of Places) represent a zoomed in view of the entity (such as a country place showing a detail of the various roads, cities, etc. within that country).
. ISL domains may have a state matrix that is similar to that of an non-domain entity, which is used primarily to store measurements and intermediate values from the interaction of the components within the subdomain.
. In general, access to the ISL is limited to administrators, and on user agents (spatial web browsers) will have a specialized entry point because of this.

== Changing Level of Detail Graphs of an Entity

. A given non-domain entity (such as a place or an agent) may have one or more __Level of Detail Links__ (__LoDs__) to a different domain that represents a drill-down of subcomponents of that entity.
. Unlike an link:#changing-internal-state-domain-of-an-entity[ISL], a Level of Detail link is typically used to provide different representations or subsystems for a given entity. A country (a place) for instance, may have one LoD showing critical population centers, another showing primary traffic routes, another showing watersheds and other features.
. An LoD domain differs from an internal state domain primarily in that it does not communicate state changes back to the parent entity. This is important because it reduces synchronization issues.
. As a rule of thumb, if there is a child domain of a given non-domain entity that has multiple overlapping and interconnected systems, these would best be contained within a single ISL, while if there are mostly disconnected systems (such as the plumbing vs. electrical system in a house), this would work better as multiple LoD systems.

== Subscribing to a Channel

. A channel is an entity, and utilizes the same mechanism that any entity does when receiving changes in state.
. In this particular case, an inbound channel has a queue that receives messages. When a message comes in, any entity that has subscribed to this channel will received a notification that new messages are in the queue that are specifically addressed to that entity.
. A domain or entity within that domain may also publish to a channel through an activity. This is what is used for multiagent communication.

== Moving an agent from one domain to another

. Agents, especially proxy agents, are typically mobile. When a proxy agent initiates a link connecting two places, a link between the old place and the agent will be augmented to indicate that the link is no longer active (likely through reification, but this is an implementation detail).
. If a link has an active credential requirement, then the credential must be presented or satisfied before the transfer can be initiated.
. Once the credentials have been satisfied, the connection between the place and the agent will be set as deprecated (likely through a reification), and a new connection is established between the target place and the agent.
. If the new place is not located on the same node, then a check is made whether there exists an agent representing the same user agent on the target node. If there is, then the agent is "revived" and any relevant history data is transferred to the new node, then a new connection is established between the target place on the new node and the proxy agent on _that_ machine. (This is primarily for performance purposes).
. The deprecated connection will also include a forwarding address to the new agent. This way, if an agent is known but it has moved "off-node", then the movement through different nodes can be traced.

== Transporting an Agent Via Another Agent

. An agent with an associated subdomain can "transport" another agent within that subdomain. This may be the case when an agent is acting as a container or carrier.
. Moving a given agent into another agent's subdomain is the same as moving an agent from one domain to another. From the standpoint of the initial domain, the "carried" agent is effectively no longer in scope of the carrier's superdomain.
. When an agent moves, the link to the subdomain for that agent remains the same - even if the agent moves from one node to another.
. The carrier agent can release the carried agent in a new place, at which point this is treated as a transfer of the carried agent from one domain to another.

== Creating a New Place

. Create an HSML Place definition and instantiate it (see link:#creating-an-entity[Creating an Entity]), appending it to the relevant domain through the `hsml:hasPlace` predicate.
. If the place is intended to be a proxy for an established place, create the relevant proxied link (e.g., Place:Earth).
. If the new place needs links to existing places, create link children (either directly on the link or indirectly through an object) on both the current place and on relevant backlinks (if the link is not bidirectional).
. Once links are created, a domain function can be identified called resolve_links, which creates backlinks if a link is bi-directional.
. Note that links are sensitive to the types of agents involved. For instance, in a chess game simulator there may be links of type rank, file, diagonal, and knight (the L shaped link) between different squares, and the movements that are possible will consequently be composed of the set of all paths that can be made to a given square from the starting square based upon the piece. The set of all possible paths that a given piece (agent) can take is known as an ensemble, and this represents the local hyperspace of that piece relative to the agent type.
. As with other entities, places can be deprecated, typically by reification.

== Creating an Entity Instance

. An __Entity Instance__ is a copy of an existing entity that is used as a template. It is frequently used in those situations where you have multiple different instances of a given environment, such as a game or simulation.
. An entity instance can only be created if the entity or some subcomponent of that entity is not a shadow for an IoT device or similar physical system that can be mutated (such as turning on a light in a smart room).
. The domain.d API includes a call to create an entity instance, which will take the current entity definition passed as a SWID and then instantiate a new instance that generates independent SWIDs and relevant identifiers.
. Entity instances do not necessarily copy affiliation credentials (this is a flag), meaning that while the original entity may be visible to an affiliation search, the instances do not necessarily need to be, though domain nodes will still appear in the landing page of the node directory, if this has been set up.

== Using the Node Domain Directory

. A user can query the spatial web node for all of the domains for which the user agent has credentials. Typically this will be supported in the node domain, which has a specific agent that allows for generating and searching these domains (a __domain directory__).
. The domain directory is a kiosk control that can also be used to view and filter the domains by their relevant topics, and provide relevant summaries and metadata for each domain.
. When invoked as JSON-LD (say via discovery applications), the domain directory generates either an HSML, Atom or RSS feed that contains this same metadata.

== Rendering an Entity

. When a query is made on domains or other entities, the request may incorporate a content-type parameter.
. If a content-type is provided, The results of the query along with the content-type are then passed to the render.d manager.
. The manager checks to see if there is a rendered plugin that matches the content type. If there is, the HSML is passed to the plugin to generate an appropriate output; if not, then the content continues as HSML.
. The output is then attached to the HSTP response message as an attachment, then sent to the requisite user-client.

== Handle Fast/Slow State Changes

. Each domain has a heartbeat that determines how frequently up updates are made (and how frequently external systems are polled). When creating the domain, the heartbeat can be established as a property on the domain, and can be increased or decreased as need be.
. For those situations where the domain does not incorporate IoT devices, this heartbeat can usually be fairly fast, as the mechanisms for transmitting information exist primarily in the same process.
. For those domains where external services or IoT device connections exist, the heartbeat can generally be slowed dow (or sped up) to handle polling or publication/subscription (pub/sub) type architectures.
. Please note that the spatial web is primarily intended to be a predictive systems, involving a large amount of contextual data, rather than a close monitoring system.
. It is possible (though the exact mechanism is still TBD) for a service to spawn a direct connection to an Iot device or similar fast moving system, one that bypasses the normal domain calles. In such cases, simple filters may be placed on incoming messages that allow for specific signals to be detected which then prompts an update back into the domain manager.

== Replication and Failover

. The specific implementation of replication is dependent upon the particular knowledge graph store in question. The assumption here is that whatever KG store will likely have some native replication for multiple servers supporting failover by periodically streaming triples that are active as part of revisions to the graph. This will likely be expressed in more detail as prototypes reach a sufficient level of  maturity.

== Scale to Internet Level

. There are multiple tiers to the proposed spatial web structure

** **Places and Agents** - These represent the fundamental layer on which the spatial web is built
** **Domains** - Domains are in effect contextual, dynamic, interactive maps. They house places, agents, and supporting structures. Domains may be linked together across multiple nodes, though a single domain can only be on one node.
** **Extended Domain Graphs** - this extends the scope of a given domain by incorporating external graphs into the systems at the query level. This makes using common codebases and templates feasible
** **Spatial Web Nodes** - Spatial web nodes are the physical backbone of the spatial web, and are primarily the servers that host the various managers of resources.
** **Affiliation Networks** - Each node (and many domains within the nodes) belong to one or more affiliation networks. Some of these may be huge, with potentially millions of nodes, others may be the equivalent of local intranets. Moreover, affiliations can themselves be affiliated, creating a superstructure that can scale up to:
** **The Spatial Web** - This is the aggregate of all affiliation networks.

. It is worth noting that not all (perhaps not even most) domains will be in publicly available affiliates. Many of these domains will be private networks intended for access only by  those with need to know (or to modify), especially those with IoT interconnections.
. The affiliate design is also a specific requirement for a decentralized architecture. A true peer-to-peer system likely will not scale to the same level (there are few Internet scale peer-to-peer systems after more than 35 years). This would especially be the case given the requirements to ensure private control over domains, along with the sensitivity of much of the internal data.

