= UDG Taxonomy

The __UDG Taxonomy__ is a taxonomy designed to augment discovery within the Spatial Web by providing common concepts and definitions for agents and, by extensions, domains.

EDITOR: UDG Taxonomy is preliminary and needs to be reviewed

== hsml:hasTopic property

The UDG Taxonomy can be thought of as the thesaurus for the Spatial Web. Each term in that thesaurus provides an adjective or noun that identifies some characteristic of a given agent.

For instance, an agent that is intended to be a proxy for a car in a smart city scenario may be identified by a number of such characteristics: the vehicle's _make_, _model_, and _trim_, its _carriage designation_ (a sedan, sports car, SUV, light truck), its _primary and secondary external and internal colors_, its _engine type_ (internal combustion engine, diesel, electric, hybrid, hydrogen-powered) and so forth. A building may be classified by _purpose_, _construction method_, _zone classification_, etc. A robot may be given by its _purpose_, _ambulatory status_, _activation level_, etc.

Each of these terms are used primarily as mechanisms for classification, and are considered as __categories__, with each particular enumeration in turn considered a __topic__. The `hsml:hasTopic`, `Place:hasTopic` and `hsml:hasTopic` properties in HSML takes zero or more topics as arguments.

[[fig-udg-taxonomy]]
.UDG Taxonomy
image::UDG_Taxonomy.png[UDG Taxonomy]


// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph LR
//     car1[<b>Agent</b><br>Car 1]:::agent
//     car2[<b>Agent</b><br>Car 2]:::agent
//     automobile[<b>Topic</b><br>Automobile]:::topic
//     sedan[<b>Topic</b><br>SUV]:::topic
//     toyota[<b>Topic</b><br>Toyota]:::topic
//     camry[<b>Topic</b><br>Camry]:::topic
//     corolla[<b>Topic</b><br>Corolla]:::topic
//     XE[<b>Topic</b><br>XE]:::topic
//     AE[<b>Topic</b><br>AE]:::topic
//     car1 -->|hsml:hasTopic| automobile & sedan & toyota & camry
//     car2 -->|hsml:hasTopic| automobile & sedan & toyota & corolla & AE
//     carriage[<b>Category</b><br>Carriage]:::category
//     make[<b>Category</b><br>Make]:::category
//     model[<b>Category</b><br>Model]:::category
//     trim[<b>Category</b><br>Trim]:::category
//     domainType[<b>Category</b><br>Domain Type]:::category
//     carriage --->|hsml:hasTopic| sedan
//     make --->|hsml:hasTopic| toyota
//     model --->|hsml:hasTopic| camry
//     model --->|hsml:hasTopic| corolla
//     trim --->|hsml:hasTopic| XE
//     trim --->|hsml:hasTopic| AE
//     domainType --->|hsml:hasTopic| automobile
// %%%    camry -->|hsml:hasConstraint| toyota
// %%%    corolla -->|hsml:hasConstraint| toyota
// %%%    XE -->|hsml:hasConstraint| camry
// %%%    AE -->|hsml:hasConstraint| corolla
//
// style car1 stroke-width:4
// classDef node stroke:black
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----

The power of the UDG taxonomy is in its ability to cluster agents by topic, mediated by category. For instance, car 1 and car 2 are both of the same make (Toyota) but of different models (Camry vs. Corolla) and trims. They are also of the same "domain Type" of automobile. Note that domain type here is not privileged, it is simply one more category that agents can be in, though a fairly broad category.

== hsml:hasConstraint property

Some times there are interdependencies between topics. For instance, the Corolla and the Camry are two different models produced by Toyota, and another car company will not produce those same models. Similarly trim provides variants for a given car model.

These relationships are called _constraints_, which is a relationship indicating that one topic is dependent upon another. This changes the diagram somewhat:

[[fig-udg-taxonomy-constraints-example]]
.An example of the UDG Taxonomy with constraints
image::UDG_taxonomy_example_with_constraints.png[an example of the UDG Taxonomy with constraints]

// https://www.mermaidchart.com/app/projects/ecd8eb1d-8b86-4074-9e57-f89503604e51/diagrams/463b3340-401b-4c6f-a24b-48310639b1db/version/v0.1/edit
// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph LR
//     car1[<b>Agent</b><br>Car 1]:::agent
//     car2[<b>Agent</b><br>Car 2]:::agent
//     automobile[<b>Topic</b><br>Automobile]:::topic
//     sedan[<b>Topic</b><br>SUV]:::topic
//     toyota[<b>Topic</b><br>Toyota]:::topic
//     camry[<b>Topic</b><br>Camry]:::topic
//     corolla[<b>Topic</b><br>Corolla]:::topic
//     XE[<b>Topic</b><br>XE]:::topic
//     AE[<b>Topic</b><br>AE]:::topic
//     car1 -->|hsml:hasTopic| automobile & sedan & toyota & camry
//     car2 -->|hsml:hasTopic| automobile & sedan & toyota & corolla & AE
//     carriage[<b>Category</b><br>Carriage]:::category
//     make[<b>Category</b><br>Make]:::category
//     model[<b>Category</b><br>Model]:::category
//     trim[<b>Category</b><br>Trim]:::category
//     domainType[<b>Category</b><br>Domain Type]:::category
//     carriage --->|hsml:hasTopic| sedan
//     make --->|hsml:hasTopic| toyota
//     model --->|hsml:hasTopic| camry
//     model --->|hsml:hasTopic| corolla
//     trim --->|hsml:hasTopic| XE
//     trim --->|hsml:hasTopic| AE
//     domainType --->|hsml:hasTopic| automobile
//     camry --->|hsml:hasConstraint| toyota
//     corolla --->|hsml:hasConstraint| toyota
//     XE -->|hsml:hasConstraint| camry
//     AE -->|hsml:hasConstraint| corolla
//
// style car1 stroke-width:4
// classDef node stroke:black
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----


== Geographic DOMAINS with `hsml:hasTopic` and `hsml:hasConstraint`

Geographic DOMAINS can be defined in a similar manner. For instance, a place may be a country, city, planet, river, lake, sea, township, etc., Each of these are `geoFeature` topics, though these may be subclassed.

For instance, Vancouver, British Columbia, Canada, and North America are all places, they are connected as follows:

[[fig-udg-taxonomy-geofeature]]
.UDG Taxonomy example with a GeoFeature
image::UDG_Taxonomy_GeoFeature.png[UDG Taxonomy example with a GeoFeature]

// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph TD
//     vancouver[<b>Place</b><br>Vancouver]:::place
//     bc[<b>Place</b><br>British Columbia]:::place
//     can[<b>Place</b><br>Canada]:::place
//     nam[<b>Place</b><br>North America]:::place
//     earth[<b>Place</b><br>Earth]:::place
//     un[<b>Agent</b><br>United Nations]:::agent
//     city[<b>Topic</b><br>City]:::topic
//     province[<b>Topic</b><br>Province]:::topic
//     country[<b>Topic</b><br>Country]:::topic
//     continent[<b>Topic</b><br>Continent]:::topic
//     planet[<b>Topic</b><br>Planet]:::topic
//     geoFeature[<b>Category</b><br>Geo-Feature]:::category
//     org[<b>Category</b><br>Organization]:::category
//     ngo[<b>Topic</b><br>Non-Governmental Organization]:::topic
//     geoFeature -->|hsml:hasTopic| city & province & country & continent & planet
//     vancouver --->|hsml:hasConstraint| bc
//     bc --->|hsml:hasConstraint| can
//     can -->|hsml:hasConstraint| nam
//     nam -->|hsml:hasConstraint| earth
//     can -->|hsml:hasConstraint| un
//     vancouver --->|hsml:hasTopic| city
//     bc --->|hsml:hasTopic| province
//     can --->|hsml:hasTopic| country
//     nam --->|hsml:hasTopic| continent
//     earth --->|hsml:hasTopic| planet
//     un ---> |hsml:hasTopic| ngo
//     org ---> |hsml:hasTopic| ngo
//
// classDef node stroke:black
// classDef place fill:lightGreen
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----

In this case, while these are all geoFeatures, Vancouver is a city while Canada is a country. Significantly, the implicit structuring (Vancouver is a part of Canada) becomes simply a constraint relationship here, albeit one that can be exploited for reasoning purposes. Furthermore, Canada might also be in another constraint relationships with an organization of countries (such as NAFTA or the United Nations), so the hierarchy here is a hierarchy of topics, and is actually more holonic than strictly hierarchical.

== Topics vs. States

At first glance, topics and state properties would appear to be similar - one could express topics as states, though they serve somewhat different purposes. A state typically associates a facet value with a normalized value indicating the strength of that value, while a topic typically is a binary relationship used for classification exclusively (you could say that a state property is a topic with a value of either 0 or 1, not something in between).

Moreover, topics tend to be relatively stable once assigned to an agent or place. This makes them useful for classification, and discovery. For instance, while it is possible to identify the state of a traffic light as being red or green, this value is likely to change regularly between queries. However, it's designation as a traffic light is very much unlikely to change. meaning that if you look for traffic lights on a given node, you will likely get all such agents.

Discovery on a given spatial web node then becomes a matter of querying the node for desired topics. Note that the topics can include synonyms (analogous to skos:altLabel) that can be compared to the base topic labels for mapping to the respective node. Moreover, multiple language versions of the same topic can be provided in order to match in different languages.

Note that topics can be used for state variables. In that particular case, however, they won't necessarily participate in search unless they are also incorporated as hsml:hasTopic objects.

== Taxonomies and Schemas with Domains

A taxonomy is a data structure that defines the topics that are relevant to that domain. The predicate `hsml:hasCategory` identifies the categories that are defined within the domain (and is a property of the hsml:Domain class). Each category in turn identifies one or more topics that are associated with that category. Because domains are named graphs, the categories defined are local to that domain.

[[fig-udg-gameworld]]
.Game World
image::GameWorld.png[Game world]

// [source,mermaid]
// ----
// graph LR
//    gameWorld[<b>Domain</b><br>Game World]
//    swords[<b>Category</b><br>Swords]
//    axes[<b>Category</b><br>Axes]
//    rapier[<b>Topic</b><br>Rapier]
//    gladius[<b>Topic</b><br>Gladius]
//    katana[<b>Topic</b><br>Katana]
//    halberd[<b>Topic</b><br>Halberd]
//    battleaxe[<b>Topic</b><br>Battle Axe]
//
//    gameWorld -->|has Category| swords & axes
//    swords -->|has Topic| rapier & gladius & katana
//    axes -->|has Topic| halberd & battleaxe
//----

== Importing Taxonomies and Schemas

The predicate hsml:includeDomain is an instruction to add the graph of the indicated domain as part of the graph search, and is applied to the hsml:Domain object. This makes it possible to import external taxonomies and schemas into an existing domain. This has a lot of utility, in that it means that a domain can be defined that contains common taxonomy and schema definitions which can then be used within another domain.

Typically, a spatial web node will contain a primary domain that contains many of the core concepts, structures, and places and common agents that may be used within the majority of domains on that node. This can be imported into any given domain, providing a common framework for terms. In general, this is like a link in that the SWURL for the resource is passed. This is then interpreted by HSML (through the graph.d engine) to add this as resource into the active graph for the domain.

This can also be done across node boundaries. A __resource repository__ is a domain server that contains various entity resources that may be used across the entirety of the spatial web. By working from these common repositories, entities such as common places, frequently defined agents, taxonomy terms, and so forth can be referenced within a domain, while staying up to date.

Note that because of latency considerations, there are times where it may be more advantageous to autoload an external domain's contents permanently onto a given spatial web node. The hsml:importDomain is similar to the hsml:includeDomain` but copies the imported domain content to the server directly, rather than referencing them from an external server. This creates an
internal domain, and requires that you specify both the external SWURL and the internal name:

----
[] a hsml:Domain ;
    hsml:swurl <domain/ExternalTaxonomy>
    hsml:importDomain <https://myExternalResources.com#domain/externalTaxonomy> .
    .
----

When this is interpreted by the hsml parser, it will retrieve the subgraph from the external domain and load it into the graph as a named graph with associated local-name SWURL. This may frequently be done from packages that are loaded in initially, and that may be periodicallly refreshed.

The primary difference between `hsml:includeDomain` and `hsml:importDomain` is that `hsml:includeDomain` creates a domain extension from the external system that is always up to date but that may have higher latency (and is not actually stored on the same node as the including domain), while the hsml:importDomain creates a local copy of the external graph in the calling graph. This graph may be out of date but that has much lower latency.

An example of an included domain would be a hotel that had a number of guest rooms, each of which were in their own domain (which may or may not be on the same spatial web node). An example of an imported domain would be one that incorporated a taxonomy that is commonly used by other domains but that also does not change frequently and may be heavily referenced.

Another way of thinking about imports vs. includes is that an import is essentially a cache of one domain within another, while, an include is a temporary reference.

Note also that in both cases, the node server MUST have the relevant credentials to load in the external domain. Otherwise this statement will fail and an error message will be sent to the error channel.

== Requirements and recommendations

TBD