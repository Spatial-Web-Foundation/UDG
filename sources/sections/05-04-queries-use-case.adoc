= Queries and examples

== Queries


=== Domain Graph Queries

There are two distinct methods that can be used for querying the state of a domain within a spatial web node: HSTP Node Queries and UDG Graph Queryies. Both of these work on the Domain Graphs for a given node, but do so in very different ways.

==== Domain Graphs

The __Domain Graph__ for a given node consists of a semantic graph that
represents all of the domains along with the relevant definition files (schema
files) and relevant scripts (activities and policies). This domain graph is
currently represented using RDF (the Resource Description Framework), though it
is possible that this may be replaced by other graph description languages in
the future.

A domain is controlled by one and only one domain manager on a spatial web node,
and a domain does not extend beyond that node.  This makes it possible to
effectively manage containment and synchronicity, as well as to ensure that the
same active agent does not appear on multiple services node servers at the same
time.

==== HSTP Node Queries

An HSTP Node query is typically sent from a client or another spatial node, and
it usually queries the state of a given domain or set of domains (or updates
that state through an interface call). Such queries represent the majority of
calls in the spatial web, and are usually bounded by credentials that determine
whether a given querant (an external agent) can in fact get specific information
about the domain from the perspective of that domain.

Node queries are often sent to a cluster of different nodes simultaneously,
where there is no guarantee that the nodes in question are even in the same
network. Such queries get back maps - descriptions of a given node limited by
the permission layers and scope of the querant that provide a view of relevant
and available items in each domain. It should be noted that such node queries
are usually expressed as HSQL, and consequently are filtered prior to being
executed in the native query format of the graph.

Such queries can also be submitted to other nodes from a given node as a form of
forwarding, though there is an upper bound as to how deep such queries can be,
using the HSTP messaging envelope to indicated where the resulting response(s)
should be sent.

[source,mermaid]
----

---
config:
    layout: elk
---
flowchart LR
cn[Client Node]
n1[Node 1]
n2[Node 2]
n3[Node 3]
n4[Node 4]
n5[Node 5]
n6[Node 6]
cn -->|request| n1 & n2
n1 -->|request| n3 & n4 & n5
n2 -->|request| n6
n1 & n2 & n3 & n4 & n5 & n6 -->|response| rq[Response Queue]
rq -->|response| cn
subgraph cs[Client System]
    cn
    rq
end
----

In the diagram, a client node sends out a query to nodes 1 and 2, which in turn
both sends a query to node 3,4,5 and 6. Each node then sends its response a
response queue to the client. It should be noted that in such a query, there is
no guarantee of order; the nodes return responses when they have completed the
query. The response queue exists to determine whether all items have either
returned a response or indicated that they have timed out, and if necessary to
transform the response into a form that the client can use.

Just as every node has a client manager, every node also has a response queue,
which contains response messages sent over hstp through hsml channels.

Again, it's worth stating that the HSTP Node query ONLY talks to domains within
a the node, though it can parameterize requests to just get one specific agent
within a domain, and it never communicates directly with the domain graph.

==== UDG Graph Queries

Each domain graph contains a wealth of information, but much of it should not,
for one reason or another, be directly exposed to a query. This is where graph
queries come in.

A __UDG Graph Query__ is a query that is made through the graph manager,
typically in the native language for that graph, and then accessible via a named
query or update. This query communicates with the full graph that is accessible
to the node.

The HSML for the domain includes soft links to dependent graphs, called
SERVICES. A __Service__ is a graph endpoint that can be queried directly from
within the graph language as if it was a specialized named graph (this is
supported by most modern RDF forms). Once defined, such graphs are otherwise
undistinguishable from normal queries, save that they may have intrinsic
latencies. Such endpoints do not necessarily need to be spatial web nodes, they
just need to be able to serialize content.

This implies that a spatial web dependent node may need to expose a graph
endpoint independent of the node itself. In the current implementation, this
would be a SPARQL or SPARQL Update endpoint, but this isn't necessarily a
requirement.

The dependent UDF graph neighborhood, unlike the SW Node query neighborhood, is
linear - you attach a dependent graph to the independent node, but it's not a
multi-tier peer-to-peer network.

Additionally, there are security risks that you have working with UDG Graph
Queries that you don't have working with node queries, as these DO have access
to information that is not protected by credentials. As a consequence, USG Graph
Queries are considered to be accessible only to the domain or node authority,
but not to most users or external agents.

==== Combining the Two

There is no reason why you cannot have both node queries and UDG queries in the
system. For instance, you can add multiple dependent graphs to the primary graph
in a given domain so that they can distributed across multiple machines. You can
then perform a node domain query on the federated distributed graph, treating it
as if was a single large graph that just happens to span more than one node.
Moreover, there is no formal requirement that a graph extension is a spatial web
node, only that it have the appropriate endpoints for graph access.

This approach will likely actually be the norm, especially for large scale
domains such as multi-user role playing games, simulations, tours, and large
scale IoT systems. If there are common resources (such as schemas, taxonomies,
scripts and so forth), then these might be contained in a separate graph server
node that is then attached to the primary graph but used by multiple spatial web
nodes at once (what's called a shared node).

[source,mermaid]
----

---
config:
    layout: elk
---
flowchart LR
p1[Primary Graph Node 1]
n2[Shared Graph Node 2]
n3[Dependent Graph Node 3]
p4[Primary Graph Node 4]
n5[Dependent Graph Node 5]
p1 -->|has dependent node| n3
p1 -->|has shared node| n2
p4 -->|has shared node| n2
p4 -->|has dependent node| n5
----

In the above illustration Node 2 is a shared node between node 1 and node 4.

Dependent nodes are also called content nodes, in that they are able to store
content that may not necessarily be HSML specific. _Note that while a spatial
web node can also expose a graph endpoint interface, content nodes that do not
also have a node manager are not considered spatial web nodes per se._



=== Named Queries and Security Considerations

Graph extensions are, by their very nature, insecure, primarily because they
exist outside of the scope of the credentialling system utilized by hstp. As a
consequence, most hstp queries will likely be invoked via a particular name,
with parameters passed as a dictionary to the graph manager. This will likely be
passed in a manner similar to MCP or the OpenAPI format.

At no time should HSTP directly call the system graph query language; it should
always go through some kind of hosted proxy (the graph manager). There are
several reasons for this:

* This provides an operational security layer, making it possible to validate an
incoming request before performing the query both from a functional and
permissions standpoint.

* The invocations better match the declarative visibility principle - an agent
can only "see" a given activity if it has the relevant credentials to do so.

* This keeps operational and sensitive data hidden from hacking through HSTP,
and it ensures that output can be transformed into "clean" versions that removes
such sensitive information before it gets sent back as part of a response.

Named queries and mutations are defined within activities at various scopes. Any
query on a domain, for instance, would in turn invoke a graph query that is
specific to that domain, and may be customed to refer to a particular agent (or
agent(s)) or place(s) in the system. It's worth noting that the domain itself
has access to all aspects of the graph, including the agents and places within
the domain.

=== Understanding Graph Queries

Graph queries are somewhat different from traditional data structures. In a
normal query, you typically pass an identifier (or some descriptive metadata),
and return a document or a list of identifiers (with metadata) to documents.

In a graph query, however, there are typically two different kinds of query. The
first is similar to a search result - a table consisting of fields of value.
This is very much akin to a SELECT query in SQL, and this form is useful for
generating reports and maps. For instance, given the current architecture, the
following query retrieves a list of all of the agents in a given domain (here, a
list of people in a given building)

[source,sparql]
----
# Sparql

SELECT (?personLabel as ?Person) (?roomLabel as ?Room)
WHERE {
    ?person a Class:Person .
    ?room a Class:Room.
    ?person rdfs:label ?personLabel .
    ?room rdfs:label ?roomLabel .
    ?room Place:hasAgent ?person .
    ?domain Domain:hasAgent ?person .
    ?domain Domain:hasPlace ?room .
} order by ?Room ?Person

----

This generates a table:

[cols="1,1", options="header"]
|===
| Person | Room
| Jane Doe | Room 101
| Karen Free | Room 101
| Bill Barnes | Room 103
| Alice Nims | Room 205
| Michel Thrush | Room 207
| Stephen Blain | Room 302
| Leeane Hardin | Room 302
|===

In this case, the select statement reads labeled properties from the WHERE
statement, which in turn matches assertions in the graph, resulting in a
subgraph.

[source,turtle]
----
# Turtle
Agent:JaneDoe a Class:Person ;
    rdfs:label "Jane Doe" ;
    .
Place:Room101 a Class:Room ;
    rdfs:label "Room 101" ;
    Place:hasAgent Agent:JaneDoe, Agent:KarenFree ;
    .
Place:Floor1 a Class:Floor ;
Place:contains Place:Room101, Place:Room102,
    Place:Room103, Place:Room104 .

Place:ApartmentBuilding1000 a Class:Building ;
    Place:contains Place:Floor1, Place:Floor2,
        Place:Floor3 .

Domain:ApartmentScenario_123 a Class:Domain ;
    Domain:hasAgent Agent:JaneDoe, Agent:KarenFree, ... ;
    Domain:hasPlace Place:Room101, Place:Room102,
     Place:Room103, ... ;
    .
...
----

Construct statements can then be used with the same WHERE statement to generate
the subgraphs as Turtle, RDF/XML or JSON-LD, along with additional metadata.


[source,sparql]
----
# Sparql

CONSTRUCT {
    ?person ?personP ?personO.
    ?room ?roomP ?roomO.
    ?domain ?domainP ?domainO.
}
WHERE {
    ?person a Class:Person .
    ?person ?personP ?personO.
    ?room a Class:Room.
    ?room ?roomP ?roomO.
    ?person rdfs:label ?personLabel .
    ?room rdfs:label ?roomLabel .
    ?room Place:hasAgent ?person .
    ?building a Class:Building .
    ?building Place:contains+ ?room .
    ?domain Domain:hasAgent ?person .
    ?domain Domain:hasPlace ?room .
    ?domain ?domainP ?domainO.
} order by ?Room ?Person

----

This will give you the graphs of ALL of the domains with all of the agents in
all of the places in each domain, where the agents are people, and the places
are rooms.

Most SPARQL queries are constraint queries - they limit the facets so that
rather than dealing with a potentially huge graph, you are dealing only with
constrained subgraphs. For instance, if you only wanted rooms that are in a
specific building, in a certain domain, you could parameterise the query to
constrain the query.

For instance, you can use the above query and set the variable `?building` to
the IRI `<Place:ApartmentBuilding1000>`. This would give you all occupied rooms
in _Apartment Building 1000_ across all domains that contain that apartment
building.

The same query, however, could also take as an argument the `?person` variable
with value `<Person:JaneDoe>`. Since there should only be one active agent in
the spatial web with this identifier, this will also tell you what apartment
building, floor, and room that particular agent is located in.

This is an important point, because it means that the results of a query will be
dependent upon a linear dictionary of named variables and values passed to the
query. This flexibility makes SPARQL queries much more powerful than their SQL
counterparts, especially when you can also use inferencing to determine the
relationships between structures. This dictionary is called a ___Query
Context___.

=== Named Queries, Mutations, and Metadata

A SPARQL query is a script that can be stored, assigned a given name (IRI),
retrieved, and evaluated wih a given context. Because the query has an IRI, it
can also store metadata, including descriptions about what kind of query context
it takes, taxonomy classification for identifying the utility of that query, and
determination about the fitness of this query compared to others. Additionally,
the script in question can be _mutational_ - it can change the state of the
graph, not just for one particular entity, but all entities that satisfy the
query context.

In the RDF graph description, the mutational capabilities are a part of SPARQL
Update, which can update the graph dynamically. At the simplest level, this can
be used to change multiple states for a given entity simultaneously, in effect
locking the graph to mutational changes outside of the scope of its own graph
update. This makes such updates ___transactional___ in nature, a key requirement
for ___data consistency___. If an update fails, the graph is returned to its
previous state.

This extends to external services as well. If an external update __service__
(such as to an IoT device) fails to complete, then this failure will propagate
through the query, and any changes made by the update service will be rolled
back.

The association of metadata with a given named query or update is significant,
because it plays a big role in __discovery__. The domain manager can interrogate
all of the agents within its scope, checking the metadata associated with the
agent, its place within the domain, and its current state. Similarly, the domain
can maintain its own metadata based upon the general domain taxonomy (covered in
its own section).

The specific mechanism for adding metadata to an entity is still under
discussion, but likely will be of the form Entity:hasTopic.

== Use Case: The Light Bulb Room

EDITOR: This use case is under review and may be updated or deleted in the future

This is a simple example of a DOMAIN. The Light Bulb room is a room with a single switch. The switch can be on or off. When the switch is on, the light is on. When the switch is off, the light is off.

=== Where
 The domain is in a __Place__ that we can call `Light Bulb Room =1`. Note that for the Domain, there was a template (or base class) called `<Light Bulb Room>`, specified via a schema language (for the moment, SHACL), that can both be used to create multiple instances, and to limit the number of instances so created.

This handles the particular situation in which a given instance is tied to a digital twin as well as the situation where a single long-running domain may exist. For the light bulb room class (LBR), if the instance was tied to a physical room, then LBR=1 would need to persist between sessions, which would mean that the SWID for the room would be persistent for all agents that had permissions to access the domain.

Note that Place in this case need only be a single value - the Room itself. The domain is the conceptual room, and there is no real reason to subdivide it into component places in this very simple model.

=== How Is Space Defined

The operational definition of a hyperspace is the set of all valid places within a domain. The spatial web (as currently defined) is a discrete spatial system. What this means in practice is that things are located in specific discrete Places, and within a domain, an agent moves from one such discrete Place to another through a link. A Place can describe the specific extent in other terms (H3, Geometric Tiles, ESRI geometries andso forth) but the domain determines which of those places are considered valid. This in turn reduces a potentially intractable geometric description into a graph-oriented topological description.

=== How Is Space Connected

In a __domain__, two or more __places__ are connected by __links__. A link is analogous to a hypertext link in HTTP. In each domain, there is typically at least one link from a source place to the __home place__ of the domain. When you "go to" a domain, you're agent is actually moving to the home place for that domain, unless another place is explicitly stated.

In the Light Bulb Room, there is only one place defined for that domain, so if you are coming from the directory domain for the SW Node, then the directory will contain a link to the LBR=1 place. Unless there is a conditional lock on the link (you have to satisfy a test condition), you (or more specifically your agent) can generatlly backtrack across links through the client

=== What

This indicates the things that are bound to the room that are controllable from within the domain. In this case, there are two distinct things - a light switch and a lamp. By activating the light switch, you enable the lamp. By deactivating the light switch, you disable the lamp. In an analog system, of course, what the light switch does is turn power off to an electrical outlet, but this is an operational detail that is unimportant to the model.

Note that there are a number of low level Things that will be generally subclassed. For instance, a lamp is a Meter that can take a value from a range of values (here [0,1]) A Toggle is a Thing that can take a Boolean value, and switch from one value to the other when activated. In short, many of these have a direct correspondance to HTML form components. These are detailed as part of the Activity specification, which is out of scope for this specification.

=== What Kind

A domain can be classified based upon a conceptual facet value tied to a specific classication facet (known as the Domain taxonomy). The specific facet can be given as a subproperty of this depending on the definition given within the associated shape.

Everything is shape based rather than class based. This means that you can use combinations of facets to determine which property shapes apply to a given entity, which in turn means that you are not as dependent upon RDFS based supclass/subproperty inheritance.

In the case of the Light Room =1,onw such classification might be IoTDevice, while another may be Purpose:Illumination or something similar.

=== Who

This indicates the agent(s) that are currently within the context of the room. There may be zero or more agents in the room at any given point, though the domain model could be set up to limit the number of agents that can occupy a given place at a certain time. This creates a crude physics.

Note that in this model as well, there is no indication about the agents are, or what priorities they have. In general, if one agent turns the light on and the other turns it off, then the system will reflect the current state from the last activity that occurred.

Agents can move from one place to another (see <<places,Places>> for more information).

=== When

Each domain has a clock. Typically, such clocks can be defined in terms of a Spatial Web Node chronometer that is specific to the host (to the extent that in many cases, the domain can refer to a specific "System Clock", which is the default chronometer when not otherwise supplied). Note that this is used primarily to control timing and action within system on the part of autonomous entities, and in general is NOT synched from one node to the next. A chronometer is of type Entity:Thing.

Also please note that the chronometer is not technically part of hyperspace. If, for instance, you had a relativity simulation, then the time component of such a transformation would be treated as a coordinate in the hyperspace system (if you are doing Lorenz Transformations, for instance), but this is only peripherally related to the domain chronometer. The chronometer is, however, a key part of maintaining a domain history (see link:=whatHappened[What Happened?].

=== What Happened

Each domain manages its own queue indicating relevant state change reports that are updated as part of the activity. This becomes the history of the domain. In this case, every time that the switch is flipped, the context of the domain for those things maintaining a history get written to the queue, indicating who initiated the action and what the state of the light (the meter) was at the time. This effectively creates a recording of the session, and in theory should be transformable to reproduce the state transitions of the system.

EDITOR: The depth of the queue will obviously be dependent upon system resources, and may be in a condensed serialized format. The exact mechanism for how this works is still TBD.

=== How

One of the roles of the chronometer is to indicate when a given domain should check to see if an expressed contextual configuration is in place (typically by querying the graph) and if it is, to then cause some activity within the domain. These are domain specific, such as expressing representations of the domain to an external channel.


=== Why

Most domains have objectives and goals. A remote drone domain, for instance, exists to get the drone to a target, perform a function, and hopefully return safely. These objectives typically will put the domain into a different state (Reset, Archive, Delete, etc.) In a game, these are the conditions that end the game and determine the winner. In a story, this is The End. In a device controller, this the termination of the updates to the devices in question. When the domain is instantiated, the why is set up as an end condition and is evaluated as part of the processing cycle for the domain.

== Application Scenario: Tourist Agent

See annex

