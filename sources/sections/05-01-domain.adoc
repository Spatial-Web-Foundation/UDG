[[domains]]
= DOMAINS as the primary ENTITY in the UDG

== ENTITIES as the basic type for all knowledge in the UDG

The primary structure for the concepts in this viewpoint is the Spatial Web Ontology and the corresponding HSML.

UDG as a conceptual graph for Knowledge representation and reasoning


[[spatial_web_ontology]]
.Spatial Web ontology
image::spatial_web_ontology.png[ontology showing Spatial Web entities and their relations]

The subsequent clasues in this clause are:

== SWIDS as the identifier used in ENTITIES

=== UDG and SWIDs

All resources within th Universal Domain Graph have some form of a __Spatial Web Identifier__ also known as a __SWID__. The SWID serves a number of purposes:

* A SWID is a __W3C Decentralized Identifier__ (__DiD__), and is used as a mechanism to make claims (assertions) about specific facts with a form of verification backing up those claims. This is known as a __Verifiable Credential__ or (__VC__).
* The SWID identifies the resource uniquely within the spatial web network. In this regard, the SWID acts as an (indirect) IRI.
* SWIDs are also used to establish links between resources. Because the VC for the SWID can hold multiple potential values, such links typically are used to combine SW Node information with Domain and Entity resolution.
* SWIDs are also used to resolve __nodelink__ connections between different nodes in the SW Node Graph, making it possible to bind together nodes in networks. In this case, the __nodelink document__ identifies both authentication and address information for different nodes within the spatial web.

=== Aliases

It should be noted that such SWIDs are not directly Uniform Resource Locators (URLs) in the WWW sense. In the Spatial Web, one or more *__aliases__* can be assigned to a SWID that is intended to locate a resource, but the actual "physical" address for the resource is contained within the SWID certificate. In effect, the alias is analogous to a HTTP domain name mapping to an IPV6 address, but in this case the "domain name" alias maps to a SWID, which then maps to the corresponding IPV6.
[source,mermaid]
----

flowchart LR
Alias --> SWID1 --> doc["Verifiable<br>Credential"]
doc --> SWNode[Spatial Web Node]
doc --> Domain[Reference Domain]
----

One key difference between HTTP and HSTP is that there is no GET parameterization on SWIDs. An alias could have such a paremeterization of course, but it becomes the role of the alias resolver to convert this into a corresponding HSML message, which then gets passed as an HSTP post message.

The specific form of aliases is still to be determined.


== Definition of a DOMAIN

A DOMAIN is the fundamental class within the UDG for describing the various
things, agents, and places that make up the Spatial Web. Every structure,
building, planet, character (agent), animal, mystical alien pyramid or similar
construct, is ultimately a DOMAIN, and is addressable within the context of the
spatial web.

A DOMAIN  can be thought of as an area of concern in which things happen. While
this may (and most likely will) be a physical construct, it doesn't necessarily
have to be.

A DOMAIN is an ENTITY that may identify the context for an ACTIVITY for or by an
AGENT at a specific place acting upon various things within that DOMAIN.
Everything that happens within the UDG happens within a DOMAIN.

A DOMAIN can be a Spatial Web representation of a thing. Internally this DOMAIN
is represented as a graph of information that describes its identifier, changing
in response to changes in its environment (the domain graph in which it resides,
which is composed of the graphs of other entities in that system).

There are a specific set of attributes which are required for the DOMAIN.
Specifically, a DOMAIN must have:

* a Spatial Web Identifier or SWID, a form of decentralized identifier that can
be used to identify the domain uniquely within the Spatial Web.

* A DOMAIN Type, which indicates the particular role that the domain plays. This
identifies how the domain is classified within the Spatial Web. Note that a
DOMAIN can be defined by multiple different ontologies, but it _must_ have the
domain type.

A DOMAIN may have other other attributes, but these are not required:

* A __location__, which identifies the entity's position in a state space (or
__hyperspace__), relative to either the containing domain, or to an externally
defined domain. If a domain exists solely as a vehicle for containment, then
location is not specifically required, though it often contains additional state
information that is not strictly speaking positional.

* Zero or more __activities__, which provides the operational instructions for
the entity in question. The structure of the activity is language independent
and declarative.

* Zero or more __style__ resources, which provides a mechanism for rendering the
entity with different content types. _Please note, this has not been formally
proposed yet, and may be removed_.

* Zero or one __link__ references to an external domain. Some entities provide a
link that can be activated through certain interfaces or affordances. This is a
simple link, meaning it changes the context (domain) of the agent initiating the
link without specific constraints, which is analogous to an HTTP standard
hyperlink. More information about links will be covered in the subsection
<<links,Links>>.


== DOMAIN types

A DOMAIN type is a specialization of an entity that incorporates additional
capabilities. Within the Spatial Web, these extensions are defined using the
Shape Constraint Language (SHACL), as a generalized schema language, with the
mechanism for such extension covered in <<domain-entity-type>>.

Currently several DOMAIN types are defined: Place, Link, Domain, Sensor, Thing,
Agent, and Assemblages, with others derivable from these.

These are differentiated as follows:

* A __place__ is defined roughly as a specific addressable location within a
domain. Places define where an entity can be, and where they can't. Cf
<<places,Places>> for more information.

* A __link__ is a mechanism for navigating between both places (internal links)
and domains (external links). It is the analog of a hypertext link in the HTTP
world.Cf. <<links,Links>> for more information.

* A __domain__ is a system of concern, and is effectively the partition of a
given universe into a navigable area. Domains are where things happen. Cf
<<domains,Domains>>.

* A __sensor__ is an abstraction of a camera, recording device, eyeball, etc.
Its purpose is to provide a reference point of view for an entity within a
domain (or of the domain itself).  Cf. <<sensors,Sensors>> for more
information.

* A __thing__ is defined as an entity that is directed by the system (the local
spatial web daemon). Not that directed here means simply that it provides the
motivating influence on the thing, not that it determines a things exact
behaviors. In effect, both things and agents are "semi-autonomous" in that they
have some (perhaps minimal) self-control, but they respond to outside
influences. Things can be considered non-player characters, but they can also be
structures, vehicles, animals, portals, and so forth. Cf. link:#things[Things]
for more details.

* An __agent__ is defined as an entity that is directable by an outside (out of
system) actor. Agents generally act as the eyes, ears, hands, and feet of the
actor. It corresponds roughly to a character in a novel, play, or game, but in a
more generalized fashion. Cf. <<agents,Agents>> for more details.

* An __assemblage__ is an aggregate structure of things, places, and agents. It
is intended to model corporations, institutions, governments, and so forth, but
it can also model physical or other composite structures.  Cf.
link:#assemblages[Assemblages] for more information.


== DOMAIN modeling checklist

A DOMAIN is a system. The DOMAIN provides the answers to a number of key
questions about the system in question.

* __Where?__. Where (what place) does the action within the system take place?
* __How Is Space Defined?__ What are the relevant places of relevance within the system (it's hyperspace).
* __How Is Spae Connected?__. How are things within the domain connected, and how are domains connected to other domains?
* __What Happened?__. Is it possible to retrieve a history of what happened within the domain over time?
* __What Kind?__. What classifications apply to the domain?
* __Who?__. Which agents are participating within the domain?
* __When?__. When does the activity take place within the context of the domain. This becomes especially critical for asynchronous events.
* __What Happened?__. Is it possible to retrieve a history of what happened within the domain over time?
* __How?__. What are the activities that can be accomplished within the domain, and how are these activated?
* __Why?__. What are the goals or purposes of the domain, and what happens when those goals are achieved?


DOMAINS exist within hyperspace including time. DOMAINS usually have a specific
start time (or other condition) and end time (or other condition).

In general, a domain has a schematic representation that can be extended from a
core domain type. This identifies the relevant state variables and properties
for the domains beyond the properties of the Domain base class. Domains are
entities in that they have swids, but they are in effect system (or holonic)
entities.


== Domain as a map

A DOMAIN is a model. It provides context for the things within the model, and also describes a purpose for that model. It is, in a very real sense, a __map__, albeit one that is self-aware and changes dynamically over time, though the question about what a domain is a map ___of___ is something that is dependent upon the author or model maker.

Something that is central to the spatial web is that it is __not__ necessarily a
reflection of reality. As with any map, a domain is an abstraction of a
(typically physical) space and the entities that evolve within that space over
time. For instance, one can create a domain showing the London subway system:

image::_116112246_064832377.jpg[London Subway System 2025]

The domain can even be seen as a representation showing where the individual
trains are within that subway system (to a close approximation). Note that such
a map is not necessarily spatially correct - it shows routes and stations, but
these are not positionally correct. In this case, what you are looking at is a
topological construct, simplified to show what is relevant, not necessarily what
is a detailed reflection of the subway on (or in this case under) the ground.

To that end, designing a domain typically comes down to answering a number of
questions:

* __What is this a map of?__ Most maps show things of significance within a given context. Why is the map being created? what is it's purpose? Just as a document exists in the world wide web to inform, entertain, record, and persuade, a domain exists in the spatial web for much the same thing.
* __Does the map change over time?__ Until recently, all maps were effectively just snapshots in time, and it has only been comparatively recently that we could create maps that capture evolution of a system over time.
* __Does the map reflect changes in the real world?__ This is a more subtle question, but an important one. Is there some form of feedback between a physical array of sensors and cameras that drive the evolution of the model, or is the driving factor in the map some form of algorithm or AI (a simulation).
* __Can changes to the map cause changes in the real world?__ Put another way, if a user of the map indicates a change be made to some entity within that map, will that change be reflected in the real world system that the map is a reflection of? Is it interactive?
* __Is the map participatory?__ Are there other agents that can change the state of the map (whether it reflects physical reality or not) and how do they interact with that map? How are changes in the map expressed back to the user.
* __Is the map linked to other maps?__ Does the map describe a comprehensive system, or is it possible to change to a different map based upon linking, tiling or similar system?
* __Does the map have multiple levels of detail (LOD)?__ Can you zoom in on an area to get more detail? Do you need to provide metadata (text and image content)? Is it dynamic?
* __Does the map have persistance?__ When an agent enters the map, will that map reflect changes made to it by others (an environment), or are changes lost between sessions (typical of tours)?
* __Who or what is the intended audience of the map?__ Is this used primarily by humans or by automated systems?

The role of the Spatial Web system is to deliver these different kinds of maps, to make them integrated and useful across a wide variety of applications. Just as the world wide web exploded the concept of a library - a collection of documents - into a world-wide phenomenon, so too does the creation of domains enable the same thing for maps as a way of perceiving and understanding the worlds, both real and imagined, around us.

== The UDG Taxonomy

The __UDG Taxonomy__ is a taxonomy designed to augment discovery within the
spatial web by providing common concepts and definitions for agents and, by
extensions, domains.

=== The hsml:hasTopic property

The UDG Taxonomy can be thought of as the thesaurus for the Spatial Web. Each
term in that thesaurus provides an adjective or noun that identifies some
characteristic of a given agent.

For instance, an agent that is intended to be a proxy for a car in a smart city
scenario may be identified by a number of such characteristics: the vehicle's
_make_, _model_, and _trim_, its _carriage designation_ (a sedan, sports car,
SUV, light truck), its _primary and secondary external and internal colors_, its
_engine type_ (internal combustion engine, diesel, electric, hybrid,
hydrogen-powered) and so forth. A building may be classified by _purpose_,
_construction method_, _zone classification_, etc. A robot may be given by its
_purpose_, _ambulatory status_, _activation level_, etc.

Each of these terms are used primarily as mechanisms for classification, and are
considered as __categories__, with each particular enumeration in turn
considered a __topic__. The `hsml:hasTopic`, `Place:hasTopic` and
`hsml:hasTopic` properties in HSML takes zero or more topics as arguments.

[[fig-udg-taxonomy]]
.UDG Taxonomy
image::UDG_Taxonomy.png[UDG Taxonomy]


// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph LR
//     car1[<b>Agent</b><br>Car 1]:::agent
//     car2[<b>Agent</b><br>Car 2]:::agent
//     automobile[<b>Topic</b><br>Automobile]:::topic
//     sedan[<b>Topic</b><br>SUV]:::topic
//     toyota[<b>Topic</b><br>Toyota]:::topic
//     camry[<b>Topic</b><br>Camry]:::topic
//     corolla[<b>Topic</b><br>Corolla]:::topic
//     XE[<b>Topic</b><br>XE]:::topic
//     AE[<b>Topic</b><br>AE]:::topic
//     car1 -->|hsml:hasTopic| automobile & sedan & toyota & camry
//     car2 -->|hsml:hasTopic| automobile & sedan & toyota & corolla & AE
//     carriage[<b>Category</b><br>Carriage]:::category
//     make[<b>Category</b><br>Make]:::category
//     model[<b>Category</b><br>Model]:::category
//     trim[<b>Category</b><br>Trim]:::category
//     domainType[<b>Category</b><br>Domain Type]:::category
//     carriage --->|hsml:hasTopic| sedan
//     make --->|hsml:hasTopic| toyota
//     model --->|hsml:hasTopic| camry
//     model --->|hsml:hasTopic| corolla
//     trim --->|hsml:hasTopic| XE
//     trim --->|hsml:hasTopic| AE
//     domainType --->|hsml:hasTopic| automobile
// %%%    camry -->|hsml:hasConstraint| toyota
// %%%    corolla -->|hsml:hasConstraint| toyota
// %%%    XE -->|hsml:hasConstraint| camry
// %%%    AE -->|hsml:hasConstraint| corolla
//
// style car1 stroke-width:4
// classDef node stroke:black
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----

The power of the UDG taxonomy is in its ability to cluster agents by topic,
mediated by category. For instance, car 1 and car 2 are both of the same make
(Toyota) but of different models (Camry vs. Corolla) and trims. They are also of
the same "domain Type" of automobile. Note that domain type here is not
privileged, it is simply one more category that agents can be in, though a
fairly broad category.

=== The `hsml:hasConstraint` Property

Some times there are interdependencies between topics. For instance, the Corolla
and the Camry are two different models produced by Toyota, and another car
company will not produce those same models. Similarly trim provides variants for
a given car model.

These relationships are called __constraints_, which is a relationship
indicating that one topic is dependent upon another. This changes the diagram
somewhat:

[[fig-udg-taxonomy-constraints-example]]
.An example of the UDG Taxonomy with constraints
image::UDG_taxonomy_example_with_constraints.png[an example of the UDG Taxonomy with constraints]

// https://www.mermaidchart.com/app/projects/ecd8eb1d-8b86-4074-9e57-f89503604e51/diagrams/463b3340-401b-4c6f-a24b-48310639b1db/version/v0.1/edit
// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph LR
//     car1[<b>Agent</b><br>Car 1]:::agent
//     car2[<b>Agent</b><br>Car 2]:::agent
//     automobile[<b>Topic</b><br>Automobile]:::topic
//     sedan[<b>Topic</b><br>SUV]:::topic
//     toyota[<b>Topic</b><br>Toyota]:::topic
//     camry[<b>Topic</b><br>Camry]:::topic
//     corolla[<b>Topic</b><br>Corolla]:::topic
//     XE[<b>Topic</b><br>XE]:::topic
//     AE[<b>Topic</b><br>AE]:::topic
//     car1 -->|hsml:hasTopic| automobile & sedan & toyota & camry
//     car2 -->|hsml:hasTopic| automobile & sedan & toyota & corolla & AE
//     carriage[<b>Category</b><br>Carriage]:::category
//     make[<b>Category</b><br>Make]:::category
//     model[<b>Category</b><br>Model]:::category
//     trim[<b>Category</b><br>Trim]:::category
//     domainType[<b>Category</b><br>Domain Type]:::category
//     carriage --->|hsml:hasTopic| sedan
//     make --->|hsml:hasTopic| toyota
//     model --->|hsml:hasTopic| camry
//     model --->|hsml:hasTopic| corolla
//     trim --->|hsml:hasTopic| XE
//     trim --->|hsml:hasTopic| AE
//     domainType --->|hsml:hasTopic| automobile
//     camry --->|hsml:hasConstraint| toyota
//     corolla --->|hsml:hasConstraint| toyota
//     XE -->|hsml:hasConstraint| camry
//     AE -->|hsml:hasConstraint| corolla
//
// style car1 stroke-width:4
// classDef node stroke:black
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----


=== Places with `hsml:hasTopic` and `hsml:hasConstraint`

Places can be defined in a similar manner. For instance, a place may be a
country, city, planet, river, lake, sea, township, etc., Each of these are
`geoFeature` topics, though these may be subclassed.

For instance, Vancouver, British Columbia, Canada, and North America are all
places, they are connected as follows:

[[fig-udg-taxonomy-geofeature]]
.UDG Taxonomy example with a GeoFeature
image::UDG_Taxonomy_GeoFeature.png[UDG Taxonomy example with a GeoFeature]

// [source,mermaid]
// ----

// ---
// config:
//     layout: elk
// ---
// graph TD
//     vancouver[<b>Place</b><br>Vancouver]:::place
//     bc[<b>Place</b><br>British Columbia]:::place
//     can[<b>Place</b><br>Canada]:::place
//     nam[<b>Place</b><br>North America]:::place
//     earth[<b>Place</b><br>Earth]:::place
//     un[<b>Agent</b><br>United Nations]:::agent
//     city[<b>Topic</b><br>City]:::topic
//     province[<b>Topic</b><br>Province]:::topic
//     country[<b>Topic</b><br>Country]:::topic
//     continent[<b>Topic</b><br>Continent]:::topic
//     planet[<b>Topic</b><br>Planet]:::topic
//     geoFeature[<b>Category</b><br>Geo-Feature]:::category
//     org[<b>Category</b><br>Organization]:::category
//     ngo[<b>Topic</b><br>Non-Governmental Organization]:::topic
//     geoFeature -->|hsml:hasTopic| city & province & country & continent & planet
//     vancouver --->|hsml:hasConstraint| bc
//     bc --->|hsml:hasConstraint| can
//     can -->|hsml:hasConstraint| nam
//     nam -->|hsml:hasConstraint| earth
//     can -->|hsml:hasConstraint| un
//     vancouver --->|hsml:hasTopic| city
//     bc --->|hsml:hasTopic| province
//     can --->|hsml:hasTopic| country
//     nam --->|hsml:hasTopic| continent
//     earth --->|hsml:hasTopic| planet
//     un ---> |hsml:hasTopic| ngo
//     org ---> |hsml:hasTopic| ngo
//
// classDef node stroke:black
// classDef place fill:lightGreen
// classDef agent fill:lightBlue
// classDef topic fill:yellow
// classDef category fill:orange
// ----

In this case, while these are all geoFeatures, Vancouver is a city while Canada
is a country. Significantly, the implicit structuring (Vancouver is a part of
Canada) becomes simply a constraint relationship here, albeit one that can be
exploited for reasoning purposes. Furthermore, Canada might also be in another
constraint relationships with an organization of countries (such as NAFTA or the
United Nations), so the hierarchy here is a hierarchy of topics, and is actually
more mereological than strictly hierarchical.

==== Domains with `hsml:hasTopic` and `hsml:hasConstraint`

The topics and constraints of a domain are the same as the topics and
constraints of the associated super-agent that binds that domain.

==== Topics vs. States

At first glance, topics and state properties would appear to be similar - one
could express topics as states, though they serve somewhat different purposes. A
state typically associates a facet value with a normalized value indicating the
strength of that value, while a topic typically is a binary relationship used
for classification exclusively (you could say that a state property is a topic
with a value of either 0 or 1, not something in between).

Moreover, topics tend to be relatively stable once assigned to an agent or
place. This makes them useful for classification, and discovery. For instance,
while it is possible to identify the state of a traffic light as being red or
green, this value is likely to change regularly between queries. However, it's
designation as a traffic light is very much unlikely to change. meaning that if
you look for traffic lights on a given node, you will likely get all such
agents.

Discovery on a given spatial web node then becomes a matter of querying the node
for desired topics. Note that the topics can include synonyms (analogous to
`skos:altLabel`) that can be compared to the base topic labels for mapping to
the respective node. Moreover, multiple language versions of the same topic can
be provided in order to match in different languages.

Note that topics can be used for state variables. In that particular case,
however, they won't necessarily participate in search unless they are also
incorporated as hsml:hasTopic objects.

==== Taxonomies and Schemas with Domains

A taxonomy is a data structure that defines the topics that are relevant to that
domain. The predicate `hsml:hasCategory` identifies the categories that are
defined within the domain (and is a property of the hsml:Domain class). Each
category in turn identifies one or more topics that are associated with that
category. Because domains are named graphs, the categories defined are local to
that domain.

[source,mermaid]
----
graph LR
    gameWorld[<b>Domain</b><br>Game World]
    swords[<b>Category</b><br>Swords]
    axes[<b>Category</b><br>Axes]
    rapier[<b>Topic</b><br>Rapier]
    gladius[<b>Topic</b><br>Gladius]
    katana[<b>Topic</b><br>Katana]
    halberd[<b>Topic</b><br>Halberd]
    battleaxe[<b>Topic</b><br>Battle Axe]

    gameWorld -->|has Category| swords & axes
    swords -->|has Topic| rapier & gladius & katana
    axes -->|has Topic| halberd & battleaxe
----

==== Importing Taxonomies and Schemas

The predicate `hsml:includeDomain` is an instruction to add the graph of the
indicated domain as part of the graph search, and is applied to the hsml:Domain
object. This makes it possible to import external taxonomies and schemas into an
existing domain. This has a lot of utility, in that it means that a domain can
be defined that contains common taxonomy and schema definitions which can then
be used within another domain.

Typically, a spatial web node will contain a primary domain that contains many
of the core concepts, structures, and places and common agents that may be used
within the majority of domains on that node. This can be imported into any given
domain, providing a common framework for terms. In general, this is like a link
in that the SWURL for the resource is passed. This is then interpreted by HSML
(through the graph.d engine) to add this as resource into the active graph for
the domain.

This can also be done across node boundaries. A __resource repository__ is a
domain server that contains various entity resources that may be used across the
entirety of the spatial web. By working from these common repositories, entities
such as common places, frequently defined agents, taxonomy terms, and so forth
can be referenced within a domain, while staying up to date.

Note that because of latency considerations, there are times where it may be
more advantageous to autoload an external domain's contents permanently onto a
given spatial web node. The `hsml:importDomain` is similar to the
`hsml:includeDomain` but copies the imported domain content to the server
directly, rather than referencing them from an external server. This creates an
internal domain, and requires that you specify both the external SWURL and the
internal name:

----
[] a hsml:Domain ;
    hsml:swurl <domain/ExternalTaxonomy>
    hsml:importDomain <https://myExternalResources.com#domain/externalTaxonomy> .
    .
----

When this is interpreted by the hsml parser, it will retrieve the subgraph from
the external domain and load it into the graph as a named graph with associated
local-name SWURL. This may frequently be done from packages that are loaded in
initially, and that may be periodicallly refreshed.

The primary difference between `hsml:includeDomain` and `hsml:importDomain` is
that `hsml:includeDomain` creates a domain extension from the external system
that is always up to date but that may have higher latency (and is not actually
stored on the same node as the including domain), while the `hsml:importDomain`
creates a local copy of the external graph in the calling graph. This graph may
be out of date but that has much lower latency.

An example of an included domain would be a hotel that had a number of guest
rooms, each of which were in their own domain (which may or may not be on the
same spatial web node). An example of an imported domain would be one that
incorporated a taxonomy that is commonly used by other domains but that also
does not change frequently and may be heavily referenced.

Another way of thinking about imports vs. includes is that an import is
essentially a cache of one domain within another, while, an include is a
temporary reference.

Note also that in both cases, the node server MUST have the relevant credentials
to load in the external domain. Otherwise this statement will fail and an error
message will be sent to the error channel.


== Domains, Links and Hyperspaces

Places have an obvious containment relationship - Earth is made up of
continents, which are made up of ountries, which are made up of cities, which
are made up of even smaller divisions.

Domains are not places, though they might appear to be at first glance. A domain
has a place property that can in fact refer to multiple places. For instance,
one can make up a domain of Red States, a domain of Blue States, and possible a
domain of Purple States in the United States. It also has a Home place property
that acts as a default when the domain is referenced as the target of a link -
this can be thought of as the equivalent of a landing page (or index.html in
HTTP terms).

This creates an interesting phenomenon. The most common form of link within the
UDG is a link from one place to another place typically within the same domain.
The links exist primarily for agents, but an agent may also have the ability to
carry certain things from one place to another within a given domain.

This is different behavior from the way that a link works in HTTP. There,
activating a link sends the browser (the user agent) to a new address. With
HSTP, activating a link will typically move the agent to a new Place within the
domain. In a game environment such as Monopoly, this basically moves the agent's
token to the new place (say from Pennsylvania Ave to Boardwalk). In a game like
chess, each player in effect controls sixteen agents, one for each chess piece
on their side, though they can only control one such agent at any given turn.

This also raises an interesting quandry. Links can be contextual, and are also
not necessarily contiguous. The valid links for a knight agent, for instance, is
L shaped, and it can jump over adjacent squares, but can't jump outside of the
boundaries of the board. The bishop can only move across diagonals, and only
until it encounters a piece of the opposite's side (a capture) or a piece of the
active side (a block). This indicates that the hyperspace of a domain is
topological.

== The Topological Hyperspace

A topological space is one in which direct physical constraints are minimized in
favor of conceptual ones. In effect, a domain consists of a set of places, each
of which is a conceptual node connected by links. The set of all places that are
traversable within the graph makeup the hyperspace for that domain, with the
links in turn controlling access from one place to another within the domain.

[source,mermaid]
----
---
config:
    layout: elk
---
graph LR
    r1[Room1]
    r2[Room2]
    r3[Room3]
    r4[Room4]
    r5[Room5]
    r6[Room6]
    r1 -->|=9758;| r2
    r1 -->|=9919;| r3
    r2 -->|=9919;| r4
    r3 -->|=9758;| r4
    r2 -->|=9758;| r3
    r4 -->|=9719;| r5
    r4 -->|=9758;| r6
----

In this case, the hyperspace for the domain consists of six "rooms", each
connected by links of various types:

* Pointers (&=9758;) represent open links - an agent can move from one room to
the next freely.

* Keys (&=9919;) represent locked links - the agent needs some form of key to
open the link and move to the next room.

* Finally, clocks (&=9719;) represents conditional locks - an external condition
(such as a store being closed for the night) must be met before traversal can
happen.

This is an example of a topological domain. It consists of six Places, but each
Place does not necessarily have to represent a physical location in the real
world. Instead, the place is simply a scope for containment. It could represent
stations in an assembly line, steps in a process, a detailed internal
representation of a given subsystem, and so forth.

The notion of linked places can be used to create an alternative for managing
holonic viewpoints. For instance, if you have a place that represents a car,
there is a link (perhaps the button that releases the latch that holds the hood
closed), which will then take you to an entry place ("room") that contains the
engine compartment, and that lets you in turn dig deeper into the engine, the
battery, the alternator and so forth.

This approach has a number of key advantages - first - you can control access to
various subsystems because they are topological just places within the overall
domain that are constrained by the links that connect them. Because links are
contextual, you can only access certain subsystem if either you (or your agent)
have the relevant key or some external condition is in force.

This also relieves the Spatial Web of having to do heavy extensive physical
mapping. This can be added back in, either by increasing the number of places to
better represent a tighter partitioning of the space, or by providing more
subtle links to create more neighborhoods (these are essentially equivlent
actions).

The hyperspace of the domain then becomes the set of all places within that
domain. This solves another problem that a more physical realization introduces
- determining whether you are at the edge of, or out of the boundaries of, a
physical space. In a topological model, if the place is not in the domain, then
it is not accessible by ANY agent.

== Topological vs Continuous Hyperspace

The topological view is one where a domain consists of a finite number of
discrete places, each with its own SWID.


== Domain Use Case: The Light Bulb Room

This is a simple example of a DOMAIN. The Light Bulb room is a room with a
single switch. The switch can be on or off. When the switch is on, the light is
on. When the switch is off, the light is off.

=== Where

The domain is in a __Place__ that we can call `Light Bulb Room =1`.

Note that for the Domain, there was a template (or base class) called `<Light
Bulb Room>`, specified via a schema language (for the moment, SHACL), that can
both be used to create multiple instances, and to limit the number of instances
so created.

This handles the particular situation in which a given instance is tied to a
digital twin as well as the situation where a single long-running domain may
exist. For the light bulb room class (LBR), if the instance was tied to a
physical room, then LBR=1 would need to persist between sessions, which would
mean that the SWID for the room would be persistent for all agents that had
permissions to access the domain.

Note that Place in this case need only be a single value - the Room itself. The
domain is the conceptual room, and there is no real reason to subdivide it into
component places in this very simple model.

=== How Is Space Defined

The operational definition of a hyperspace is the set of all valid places within
a domain. The spatial web (as currently defined) is a discrete spatial system.
What this means in practice is that things are located in specific discrete
Places, and within a domain, an agent moves from one such discrete Place to
another through a link. A Place can describe the specific extent in other terms
(H3, Geometric Tiles, ESRI geometries andso forth) but the domain determines
which of those places are considered valid. This in turn reduces a potentially
intractable geometric description into a graph-oriented topological description.

=== How Is Space Connected

In a __domain__, two or more __places__ are connected by __links__. A link is
analogous to a hypertext link in HTTP. In each domain, there is typically at
least one link from a source place to the __home place__ of the domain. When you
"go to" a domain, you're agent is actually moving to the home place for that
domain, unless another place is explicitly stated.

In the Light Bulb Room, there is only one place defined for that domain, so if
you are coming from the directory domain for the SW Node, then the directory
will contain a link to the LBR=1 place. Unless there is a conditional lock on
the link (you have to satisfy a test condition), you (or more specifically your
agent) can generatlly backtrack across links through the client

=== What

This indicates the things that are bound to the room that are controllable from
within the domain. In this case, there are two distinct things - a light switch
and a lamp. By activating the light switch, you enable the lamp. By deactivating
the light switch, you disable the lamp. In an analog system, of course, what the
light switch does is turn power off to an electrical outlet, but this is an
operational detail that is unimportant to the model.

Note that there are a number of low level Things that will be generally
subclassed. For instance, a lamp is a Meter that can take a value from a range
of values (here [0,1]) A Toggle is a Thing that can take a Boolean value, and
switch from one value to the other when activated. In short, many of these have
a direct correspondance to HTML form components. These are detailed as part of
the Activity specification, which is out of scope for this specification.

=== What Kind

A domain can be classified based upon a conceptual facet value tied to a
specific classication facet (known as the Domain taxonomy). The specific facet
can be given as a subproperty of this depending on the definition given within
the associated shape.

Everything is shape based rather than class based. This means that you can use
combinations of facets to determine which property shapes apply to a given
entity, which in turn means that you are not as dependent upon RDFS based
supclass/subproperty inheritance.

In the case of the Light Room =1,onw such classification might be IoTDevice,
while another may be Purpose:Illumination or something similar.

=== Who

This indicates the agent(s) that are currently within the context of the room.
There may be zero or more agents in the room at any given point, though the
domain model could be set up to limit the number of agents that can occupy a
given place at a certain time. This creates a crude physics.

Note that in this model as well, there is no indication about the agents are, or
what priorities they have. In general, if one agent turns the light on and the
other turns it off, then the system will reflect the current state from the last
activity that occurred.

Agents can move from one place to another (see <<places,Places>> for more information).

=== When

Each domain has a clock. Typically, such clocks can be defined in terms of a
Spatial Web Node chronometer that is specific to the host (to the extent that in
many cases, the domain can refer to a specific "System Clock", which is the
default chronometer when not otherwise supplied). Note that this is used
primarily to control timing and action within system on the part of autonomous
entities, and in general is NOT synched from one node to the next. A chronometer
is of type Entity:Thing.

Also please note that the chronometer is not technically part of hyperspace. If,
for instance, you had a relativity simulation, then the time component of such a
transformation would be treated as a coordinate in the hyperspace system (if you
are doing Lorenz Transformations, for instance), but this is only peripherally
related to the domain chronometer. The chronometer is, however, a key part of
maintaining a domain history (see link:=whatHappened[What Happened?].

=== What Happened

Each domain manages its own queue indicating relevant state change reports that
are updated as part of the activity. This becomes the history of the domain. In
this case, every time that the switch is flipped, the context of the domain for
those things maintaining a history get written to the queue, indicating who
initiated the action and what the state of the light (the meter) was at the
time. This effectively creates a recording of the session, and in theory should
be transformable to reproduce the state transitions of the system.

EDITOR: The depth of the queue will obviously be dependent upon system
resources, and may be in a condensed serialized format. The exact mechanism for
how this works is still TBD.

=== How

One of the roles of the chronometer is to indicate when a given domain should
check to see if an expressed contextual configuration is in place (typically by
querying the graph) and if it is, to then cause some activity within the domain.
These are domain specific, such as expressing representations of the domain to
an external channel.

EDITOR: The details of Activity are still being worked out, and will be updated
accordingly here.

=== Why

Most domains have objectives and goals. A remote drone domain, for instance,
exists to get the drone to a target, perform a function, and hopefully return
safely. These objectives typically will put the domain into a different state
(Reset, Archive, Delete, etc.) In a game, these are the conditions that end the
game and determine the winner. In a story, this is The End. In a device
controller, this the termination of the updates to the devices in question. When
the domain is instantiated, the why is set up as an end condition and is
evaluated as part of the processing cycle for the domain.

== UDG SWIDs and Aliases

=== UDG and SWIDs

All resources within th Universal Domain Graph have some form of a __Spatial Web
Identifier__ also known as a __SWID__. The SWID serves a number of purposes:

* A SWID is a __W3C Decentralized Identifier__ (__DiD__), and is used as a mechanism to make claims (assertions) about specific facts with a form of verification backing up those claims. This is known as a __Verifiable Credential__ or (__VC__).
* The SWID identifies the resource uniquely within the spatial web network. In this regard, the SWID acts as an (indirect) IRI.
* SWIDs are also used to establish links between resources. Because the VC for the SWID can hold multiple potential values, such links typically are used to combine SW Node information with Domain and Entity resolution.
* SWIDs are also used to resolve __nodelink__ connections between different nodes in the SW Node Graph, making it possible to bind together nodes in networks. In this case, the __nodelink document__ identifies both authentication and address information for different nodes within the spatial web.

=== Aliases

It should be noted that such SWIDs are not directly Uniform Resource Locators
(URLs) in the WWW sense. In the Spatial Web, one or more *__aliases__* can be
assigned to a SWID that is intended to locate a resource, but the actual
"physical" address for the resource is contained within the SWID certificate. In
effect, the alias is analogous to a HTTP domain name mapping to an IPV6 address,
but in this case the "domain name" alias maps to a SWID, which then maps to the
corresponding IPV6.

[source,mermaid]
----
flowchart LR
Alias --> SWID1 --> doc["Verifiable<br>Credential"]
doc --> SWNode[Spatial Web Node]
doc --> Domain[Reference Domain]
----

One key difference between HTTP and HSTP is that there is no GET
parameterization on SWIDs. An alias could have such a paremeterization of
course, but it becomes the role of the alias resolver to convert this into a
corresponding HSML message, which then gets passed as an HSTP post message.

The specific form of aliases is still to be determined.

== Domain Use Case: The Light Bulb Room

This is a simple example of a DOMAIN. The Light Bulb room is a room with a
single switch. The switch can be on or off. When the switch is on, the light is
on. When the switch is off, the light is off.

=== Where

The domain is in a __Place__ that we can call `Light Bulb Room =1`. Note that
for the Domain, there was a template (or base class) called `<Light Bulb Room>`,
specified via a schema language (for the moment, SHACL), that can both be used
to create multiple instances, and to limit the number of instances so created.

This handles the particular situation in which a given instance is tied to a
digital twin as well as the situation where a single long-running domain may
exist. For the light bulb room class (LBR), if the instance was tied to a
physical room, then LBR=1 would need to persist between sessions, which would
mean that the SWID for the room would be persistent for all agents that had
permissions to access the domain.

Note that Place in this case need only be a single value - the Room itself. The
domain is the conceptual room, and there is no real reason to subdivide it into
component places in this very simple model.

=== How Is Space Defined

The operational definition of a hyperspace is the set of all valid places within
a domain. The spatial web (as currently defined) is a discrete spatial system.
What this means in practice is that things are located in specific discrete
Places, and within a domain, an agent moves from one such discrete Place to
another through a link. A Place can describe the specific extent in other terms
(H3, Geometric Tiles, ESRI geometries andso forth) but the domain determines
which of those places are considered valid. This in turn reduces a potentially
intractable geometric description into a graph-oriented topological description.

=== How Is Space Connected

In a __domain__, two or more __places__ are connected by __links__. A link is
analogous to a hypertext link in HTTP. In each domain, there is typically at
least one link from a source place to the __home place__ of the domain. When you
"go to" a domain, you're agent is actually moving to the home place for that
domain, unless another place is explicitly stated.

In the Light Bulb Room, there is only one place defined for that domain, so if
you are coming from the directory domain for the SW Node, then the directory
will contain a link to the LBR=1 place. Unless there is a conditional lock on
the link (you have to satisfy a test condition), you (or more specifically your
agent) can generatlly backtrack across links through the client

=== What

This indicates the things that are bound to the room that are controllable from
within the domain. In this case, there are two distinct things - a light switch
and a lamp. By activating the light switch, you enable the lamp. By deactivating
the light switch, you disable the lamp. In an analog system, of course, what the
light switch does is turn power off to an electrical outlet, but this is an
operational detail that is unimportant to the model.

Note that there are a number of low level Things that will be generally
subclassed. For instance, a lamp is a Meter that can take a value from a range
of values (here [0,1]) A Toggle is a Thing that can take a Boolean value, and
switch from one value to the other when activated. In short, many of these have
a direct correspondance to HTML form components. These are detailed as part of
the Activity specification, which is out of scope for this specification.

=== What Kind

A domain can be classified based upon a conceptual facet value tied to a
specific classication facet (known as the Domain taxonomy). The specific facet
can be given as a subproperty of this depending on the definition given within
the associated shape.

Everything is shape based rather than class based. This means that you can use
combinations of facets to determine which property shapes apply to a given
entity, which in turn means that you are not as dependent upon RDFS based
supclass/subproperty inheritance.

In the case of the Light Room =1,onw such classification might be IoTDevice,
while another may be Purpose:Illumination or something similar.

=== Who

This indicates the agent(s) that are currently within the context of the room.
There may be zero or more agents in the room at any given point, though the
domain model could be set up to limit the number of agents that can occupy a
given place at a certain time. This creates a crude physics.

Note that in this model as well, there is no indication about the agents are, or
what priorities they have. In general, if one agent turns the light on and the
other turns it off, then the system will reflect the current state from the last
activity that occurred.

Agents can move from one place to another (see <<places,Places>> for more information).

=== When

Each domain has a clock. Typically, such clocks can be defined in terms of a
Spatial Web Node chronometer that is specific to the host (to the extent that in
many cases, the domain can refer to a specific "System Clock", which is the
default chronometer when not otherwise supplied). Note that this is used
primarily to control timing and action within system on the part of autonomous
entities, and in general is NOT synched from one node to the next. A chronometer
is of type Entity:Thing.

Also please note that the chronometer is not technically part of hyperspace. If,
for instance, you had a relativity simulation, then the time component of such a
transformation would be treated as a coordinate in the hyperspace system (if you
are doing Lorenz Transformations, for instance), but this is only peripherally
related to the domain chronometer. The chronometer is, however, a key part of
maintaining a domain history (see link:=whatHappened[What Happened?].

=== What Happened

Each domain manages its own queue indicating relevant state change reports that
are updated as part of the activity. This becomes the history of the domain. In
this case, every time that the switch is flipped, the context of the domain for
those things maintaining a history get written to the queue, indicating who
initiated the action and what the state of the light (the meter) was at the
time. This effectively creates a recording of the session, and in theory should
be transformable to reproduce the state transitions of the system.

EDITOR: The depth of the queue will obviously be dependent upon system
resources, and may be in a condensed serialized format. The exact mechanism for
how this works is still TBD.

=== How

One of the roles of the chronometer is to indicate when a given domain should
check to see if an expressed contextual configuration is in place (typically by
querying the graph) and if it is, to then cause some activity within the domain.
These are domain specific, such as expressing representations of the domain to
an external channel.

EDITOR: The details of Activity are still being worked out, and will be updated
accordingly here.

=== Why

Most domains have objectives and goals. A remote drone domain, for instance,
exists to get the drone to a target, perform a function, and hopefully return
safely. These objectives typically will put the domain into a different state
(Reset, Archive, Delete, etc.) In a game, these are the conditions that end the
game and determine the winner. In a story, this is The End. In a device
controller, this the termination of the updates to the devices in question. When
the domain is instantiated, the why is set up as an end condition and is
evaluated as part of the processing cycle for the domain.


